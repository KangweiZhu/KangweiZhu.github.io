{"title":"面试准备（中文）","uid":"45bc3f8018679bb0e90c1a916f18ee22","slug":"面试准备","date":"2024-04-07T22:35:48.000Z","updated":"2024-04-11T12:25:26.007Z","comments":true,"path":"api/articles/面试准备.json","keywords":"Kangwei Zhu's Blog","cover":[],"content":"<h1 id=\"1-计算机网络\"><a href=\"#1-计算机网络\" class=\"headerlink\" title=\"1. 计算机网络\"></a>1. 计算机网络</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>看了不下三四十份面经，所有部分都属于必问。</p>\n<p>文章内容 基于 Javaguide.cn 提供的资料，进行整合和总结。</p>\n<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 链接：<a href=\"https://javaguide.cn/cs-basics/network\">https://javaguide.cn/cs-basics/network</a></p></blockquote>\n<h2 id=\"1-1-TCP-三次握手和四次挥手（传输层）\"><a href=\"#1-1-TCP-三次握手和四次挥手（传输层）\" class=\"headerlink\" title=\"1.1 TCP 三次握手和四次挥手（传输层）\"></a>1.1 TCP 三次握手和四次挥手（传输层）</h2><h3 id=\"1-1-1-建立连接-TCP-三次握手\"><a href=\"#1-1-1-建立连接-TCP-三次握手\" class=\"headerlink\" title=\"1.1.1 建立连接-TCP 三次握手\"></a>1.1.1 <a href=\"https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-tcp-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\">建立连接-TCP 三次握手</a></h3><p><img src=\"https://lh7-us.googleusercontent.com/EVTI6TXheQYPdQKcaHbWBpzevMja1OxTfH6eHo6bixedlRIz7SxqVMwkjoKQAoSZpd_YIhHK3vkAE2uVbXmNPwGJJk-CAV3SUxnB6_eyZG1Db-Ykg4AOPVB42btyrBofGIGoj9MdSwSt7pkFyHIcRA\" alt=\"img\"><br>第一次 （客户端给服务器发送 SYN 后，进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认)</p>\n<ul>\n<li><p>Client: 啥也没有，</p>\n</li>\n<li><p>Server： Client发， Server收</p>\n</li>\n</ul>\n<p>第二次 （服务器发 SYN + ACK 给客户端后，进入 <strong>SYN_RECV</strong> 状态）</p>\n<ul>\n<li><p>Client: Client发，Client收，Server发，Server收 （已经确认好）</p>\n</li>\n<li><p>Server啥也没有</p>\n</li>\n</ul>\n<p>第三次（客户端发送 ACK 给服务器后，客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态）</p>\n<ul>\n<li><p>Client啥也没有</p>\n</li>\n<li><p>Server: Client发， Client收， Server发，Server收 (已经确认好)</p>\n</li>\n</ul>\n<p><strong>Client 和 Server 两边，都要确定各自能够收发数据，这就是 三次握手 的意义</strong></p>\n<h4 id=\"1-1-1-1-第-2-次握手传回了-ACK，为什么还要传回-SYN？\"><a href=\"#1-1-1-1-第-2-次握手传回了-ACK，为什么还要传回-SYN？\" class=\"headerlink\" title=\"1.1.1.1 第 2 次握手传回了 ACK，为什么还要传回 SYN？\"></a>1.1.1.1 <a href=\"#%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ack-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-syn\">第 2 次握手传回了 ACK，为什么还要传回 SYN？</a></h4><p>服务端传回发送端所发送的 ACK 是为了告诉客户端：“我接收到的信息确实就是你所发送的信号了”，这表明从客户端到服务端的通信是正常的。回传 SYN 则是为了建立并确认从服务端到客户端的通信。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SYN 同步序列编号(Synchronize Sequence Numbers) 是 TCP&#x2F;IP 建立连接时使用的握手信号。在客户机和服务器之间建立正常的 TCP 网络连接时，客户机首先发出一个 SYN 消息，服务器使用 SYN-ACK 应答表示接收到了这个消息，最后客户机再以 ACK(Acknowledgement）消息响应。这样在客户机和服务器之间才能建立起可靠的 TCP 连接，数据才可以在客户机和服务器之间传递。</p></blockquote>\n<hr>\n<h3 id=\"1-1-2-断开连接-TCP-四次挥手\"><a href=\"#1-1-2-断开连接-TCP-四次挥手\" class=\"headerlink\" title=\"1.1.2 断开连接-TCP 四次挥手\"></a>1.1.2 <a href=\"https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-tcp-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\">断开连接-TCP 四次挥手</a></h3><p><img src=\"/../img/image-20240409000115948.png\" alt=\"image-20240409000115948\"></p>\n<p><strong>断开一个 TCP 连接</strong>则需要“四次挥手”，缺一不可：</p>\n<ol>\n<li><strong>第一次挥手</strong>：客户端发送一个 FIN（SEQ&#x3D;x） 标志的数据包-&gt;服务端，用来关闭<strong>客户端到服务器的数据传送</strong>。然后客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li>\n<li><strong>第二次挥手</strong>：服务器收到这个 FIN（SEQ&#x3D;X） 标志的数据包，它发送一个 ACK （ACK&#x3D;x+1）标志的数据包-&gt;客户端 。然后服务端进入 <strong>CLOSE-WAIT</strong> 状态，客户端进入 <strong>FIN-WAIT-2</strong> 状态。</li>\n<li><strong>第三次挥手</strong>：服务端发送一个 FIN (SEQ&#x3D;y)标志的数据包-&gt;客户端，请求<strong>关闭连接</strong>，然后服务端进入 <strong>LAST-ACK</strong> 状态。</li>\n<li><strong>第四次挥手</strong>：客户端发送 ACK (ACK&#x3D;y+1)标志的数据包-&gt;服务端，然后客户端进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (ACK&#x3D;y+1)标志的数据包后进入 CLOSE 状态。此时如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后<strong>客户端也可以关闭连接</strong>了。</li>\n</ol>\n<p><strong>只要四次挥手没有结束，客户端和服务端就可以继续传输数据！</strong></p>\n<ul>\n<li><p><strong>大白话版流程：</strong> </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>服务器最先关，客户端最后关。</p></blockquote>\n<ul>\n<li>客户端： 往服务器发送FIN, 告诉服务端：关闭数据传送， 自身进入 <strong>FIN-WAIT-1</strong> 状态。</li>\n<li>服务端： 收到来自客户端的FIN，立刻向 客户端 发送ack, 表示知道了， 自身进入 <strong>CLOSE-WAIT</strong> 状态。</li>\n<li>客户端： 收到来自服务器的 ack,  自身进入<strong>FIN-WAIT-2</strong>状态。</li>\n<li>服务端： 如果在此时， 服务端还有 <strong>未完成的</strong> <strong>向客户端的数据传输</strong> 的话，则在数据完成传输后，向客户端发FIN, 告诉客户端，我要关闭连接了。 反之，如果不存在 任何传输任务，则和 三次握手<strong>几乎</strong>没有区别，ACK和FIN会<strong>几乎同时（还是有先后顺序的）</strong>发送 。发完FIN后， 自身进入 <strong>LAST-ACK</strong> 状态</li>\n<li>客户端 收到来自服务器的 关闭连接请求， 于是发送 ACK给服务器， 服务器收到了，就关了（<strong>ClOSE 状态</strong>）。客户端会等一会，没有服务器的恢复了，也就 <strong>CLOSED状态</strong>了</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"1-1-2-1-为什么要四次挥手？\"><a href=\"#1-1-2-1-为什么要四次挥手？\" class=\"headerlink\" title=\"1.1.2.1 为什么要四次挥手？\"></a>1.1.2.1 <a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\">为什么要四次挥手？</a></h4><p>TCP 是全双工通信，可以双向传输数据。任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全<strong>关闭了 TCP 连接</strong>。</p>\n<p>举个例子：A 和 B 打电话，通话即将结束后。</p>\n<ol>\n<li><strong>第一次挥手</strong>：A 说“我没啥要说的了”</li>\n<li><strong>第二次挥手</strong>：B 回答“我知道了”，但是 B 可能还会有要说的话，A 不能要求 B 跟着自己的节奏结束通话</li>\n<li><strong>第三次挥手</strong>：于是 B 可能又巴拉巴拉说了一通，最后 B 说“我说完了”</li>\n<li><strong>第四次挥手</strong>：A 回答“知道了”，这样通话才算结束</li>\n</ol>\n<h4 id=\"1-1-2-2-为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？\"><a href=\"#1-1-2-2-为什么不能把服务器发送的-ACK-和-FIN-合并起来，变成三次挥手？\" class=\"headerlink\" title=\"1.1.2.2 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？\"></a>1.1.2.2 <a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ack-%E5%92%8C-fin-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5-%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B\">为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</a></h4><p>因为服务器收到客户端断开连接的请求时，可能还有<strong>一些数据没有发完</strong>，这时先回复 ACK，表示<strong>接收</strong>到了断开连接的请求。等到数据发完之后再发 FIN，<strong>断开服务器到客户端的数据传送</strong>。</p>\n<h4 id=\"1-1-2-3-如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？\"><a href=\"#1-1-2-3-如果第二次挥手时服务器的-ACK-没有送达客户端，会怎样？\" class=\"headerlink\" title=\"1.1.2.3 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？\"></a>1.1.2.3 <a href=\"https://javaguide.cn/cs-basics/network/tcp-connection-and-disconnection.html#%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ack-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF-%E4%BC%9A%E6%80%8E%E6%A0%B7\">如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</a></h4><p>客户端没有收到 ACK 确认，会重新发送 FIN 请求。</p>\n<h4 id=\"1-1-2-4-为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？\"><a href=\"#1-1-2-4-为什么第四次挥手客户端需要等待-2-MSL（报文段最长寿命）时间后才进入-CLOSED-状态？\" class=\"headerlink\" title=\"1.1.2.4 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？\"></a>1.1.2.4 <a href=\"#%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-msl-%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD-%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-closed-%E7%8A%B6%E6%80%81\">为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</a></h4><p>第四次挥手时，<strong>客户端发送给服务器的 ACK</strong> 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会<strong>重发 FIN</strong>，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p>\n<ul>\n<li><strong>大白话讲</strong>， 就是服务器 就等你客户端 通知了，通知一到服务器连接立马关闭。但是客户端的通知可能会发不到，导致服务器连接 没法关，客户端反倒关掉了（<strong>变成单向连接了</strong>）。为了解决这个问题，服务器 收不到客户端通知的话， 就会重发FIN<strong>（重新来一次第三次挥手）</strong>，那么为了<strong>容错</strong>，客户端就得慢点关： 等一下（<strong>客户端自身发ACK （丢失了）+ 服务器重发FIN的时间 &#x3D;  MSL + MSL &#x3D; 2MSL</strong>）。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></blockquote>\n<h2 id=\"1-2-HTTP-vs-HTTPS（应用层）\"><a href=\"#1-2-HTTP-vs-HTTPS（应用层）\" class=\"headerlink\" title=\"1.2 HTTP vs HTTPS（应用层）\"></a>1.2 HTTP vs HTTPS（应用层）</h2><h3 id=\"1-2-1-HTTP-协议介绍\"><a href=\"#1-2-1-HTTP-协议介绍\" class=\"headerlink\" title=\"1.2.1 HTTP 协议介绍\"></a>1.2.1 HTTP 协议介绍</h3><p>HTTP 协议，全称超文本传输协议（Hypertext Transfer Protocol）。顾名思义，HTTP 协议就是用来<strong>规范超文本的传输</strong>。超文本，也就是<strong>网络上的包括文本在内的各式各样的消息</strong>，具体来说，主要是来规范浏览器和服务器端的行为的。</p>\n<p>并且，HTTP 是一个<strong>无状态（stateless）</strong>协议，也就是说<strong>服务器不维护任何有关客户端过去所发请求</strong>的消息。这其实是一种懒政，有状态协议会更加复杂，需要维护状态（历史信息），而且如果客户或服务器失效，会产生状态的不一致，解决这种不一致的代价更高。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>HTTP和HTTPS在状态管理方面是相同的；<strong>都是无状态协议</strong>。这意味着协议自身不会记住之前的请求或响应。每个请求都是独立的，服务器不会自动记住之前与该客户端的任何交互。</p>\n<p>无状态的特性指的是协议对于事务处理没有记忆能力，服务器不知道客户端是第一次请求还是后续请求。这一设计允许HTTP协议简单且快速，但同时也带来了如何维护用户会话（即“状态”）的问题。</p>\n<p>为了解决这个问题，通常会使用如<strong>Cookies、Session等技术来跟踪和保存用户状态</strong>。这些技术允许服务器识别用户请求之间的连续性，但它们是建立在<strong>HTTP&#x2F;HTTPS之上的应用层</strong>解决方案，而<strong>不是协议本身的特性</strong>。</p>\n<p>HTTPS实际上是HTTP的安全版本，它在HTTP的基础上通过SSL&#x2F;TLS提供数据加密、数据完整性验证和数据源认证等安全特性。因此，HTTPS继承了HTTP的无状态特性，同时增加了数据传输的安全性。换句话说，HTTPS并不是因为引入了加密就变成了有状态的协议。无论是HTTP还是HTTPS，它们都需要额外的机制如Cookies来管理状态。</p></blockquote>\n<ul>\n<li>HTTP 是应用层协议，它以 TCP（传输层）作为底层协议，默认端口为 80</li>\n</ul>\n<h3 id=\"1-2-2-HTTP-通信流程\"><a href=\"#1-2-2-HTTP-通信流程\" class=\"headerlink\" title=\"1.2.2  HTTP 通信流程\"></a>1.2.2  HTTP 通信流程</h3><ol>\n<li><strong>服务器</strong>在 <strong>80 端口</strong>等待客户的请求。</li>\n<li><strong>浏览器发起</strong>到服务器的 <strong>TCP 连接</strong>（创建套接字 Socket）。</li>\n<li><strong>服务器接收</strong>来自浏览器的 TCP 连接。</li>\n<li>浏览器（HTTP 客户端）与 Web 服务器（HTTP 服务器）<strong>交换 HTTP 消息</strong>。</li>\n<li>关闭 TCP 连接。</li>\n</ol>\n<h3 id=\"1-2-3-HTTP-优点\"><a href=\"#1-2-3-HTTP-优点\" class=\"headerlink\" title=\"1.2.3 HTTP 优点\"></a>1.2.3 HTTP 优点</h3><ul>\n<li>扩展性强、<strong>速度快</strong>（主要）、跨平台支持性好。</li>\n</ul>\n<h3 id=\"1-2-4-HTTPS-协议介绍\"><a href=\"#1-2-4-HTTPS-协议介绍\" class=\"headerlink\" title=\"1.2.4 HTTPS 协议介绍\"></a>1.2.4 HTTPS 协议介绍</h3><p>HTTPS 协议（Hyper Text Transfer Protocol Secure），是 HTTP 的<strong>加强安全版本</strong>。HTTPS 是<strong>基于 HTTP</strong> 的，<strong>也是用 TCP</strong> 作为底层协议，并<strong>额外使用 SSL&#x2F;TLS 协议</strong>用作<strong>加密和安全认证</strong>。默认端口号是 <strong>443</strong>.</p>\n<p>HTTPS 协议中，SSL 通道通常使用基于密钥的加密算法，密钥长度通常是 <strong>40 比特</strong>或 <strong>128 比特</strong>。</p>\n<h3 id=\"1-2-5-HTTPS-协议优点\"><a href=\"#1-2-5-HTTPS-协议优点\" class=\"headerlink\" title=\"1.2.5 HTTPS 协议优点\"></a>1.2.5 HTTPS 协议优点</h3><ul>\n<li>保密性好、信任度高。&#x3D;&gt; <strong>安全</strong></li>\n</ul>\n<h3 id=\"1-2-6-HTTPS-的核心—SSL-TLS-协议\"><a href=\"#1-2-6-HTTPS-的核心—SSL-TLS-协议\" class=\"headerlink\" title=\"1.2.6 HTTPS 的核心—SSL&#x2F;TLS 协议\"></a>1.2.6 HTTPS 的核心—SSL&#x2F;TLS 协议</h3><p>HTTPS 之所以能达到较高的安全性要求，就是结合了 SSL&#x2F;TLS 和 TCP 协议，对通信数据进行加密，<strong>解决了 HTTP 数据透明的问题</strong>。接下来重点介绍一下 SSL&#x2F;TLS 的工作原理。</p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>SSL&#x2F;TLS 的核心要素是<strong>非对称加密</strong>。非对称加密采用两个密钥——一个公钥，一个私钥。在通信时，私钥仅由解密者保存，公钥由任何一个想与解密者通信的发送者（加密者）所知。可以设想一个场景，</p>\n<blockquote>\n<p>在某个自助邮局，每个通信信道都是一个邮箱，每一个邮箱所有者都在旁边立了一个牌子，上面挂着一把钥匙：这是我的公钥，发送者请将信件放入我的邮箱，并用公钥锁好。</p>\n<p>但是公钥只能加锁，并不能解锁。解锁只能由邮箱的所有者——因为只有他保存着私钥。</p>\n<p>这样，通信信息就不会被其他人截获了，这依赖于私钥的保密性</p></blockquote>\n<hr>\n<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href=\"https://javaguide.cn/cs-basics/network/http-vs-https.html\">https://javaguide.cn/cs-basics/network/http-vs-https.html</a></p>\n</blockquote>\n<h3 id=\"1-2-6-1-SSL-和-TLS-的区别？\"><a href=\"#1-2-6-1-SSL-和-TLS-的区别？\" class=\"headerlink\" title=\"1.2.6.1 SSL 和 TLS 的区别？\"></a><a href=\"#ssl-%E5%92%8C-tls-%E7%9A%84%E5%8C%BA%E5%88%AB\">1.2.6.1 SSL 和 TLS 的区别？</a></h3><p><strong>SSL 和 TLS 没有太大的区别。</strong></p>\n<p>SSL 指安全套接字协议（Secure Sockets Layer），首次发布与 1996 年。SSL 的首次发布其实已经是他的 3.0 版本，SSL 1.0 从未面世，SSL 2.0 则具有较大的缺陷（DROWN 缺陷——Decrypting RSA with Obsolete and Weakened eNcryption）。很快，在 1999 年，SSL 3.0 进一步升级，<strong>新版本被命名为 TLS 1.0</strong>。因此，<strong>TLS 是基于 SSL 之上的</strong>，但由于<strong>习惯</strong>叫法，通常把 HTTPS 中的核心加密协议<strong>混称为 SSL&#x2F;TLS</strong>。</p>\n<hr>\n<p>著作权归JavaGuide(javaguide.cn)所有 基于MIT协议 原文链接：<a href=\"https://javaguide.cn/cs-basics/network/http-vs-https.html\">https://javaguide.cn/cs-basics/network/http-vs-https.html</a></p>\n<h2 id=\"1-3-TCP-如何保证传输的可靠性？\"><a href=\"#1-3-TCP-如何保证传输的可靠性？\" class=\"headerlink\" title=\"1.3 TCP 如何保证传输的可靠性？\"></a>1.3 TCP 如何保证传输的可靠性？</h2><ol>\n<li><strong>基于数据块传输</strong>：应用数据被分割成 TCP 认为最适合发送的数据块，再传输给网络层，数据块被称为报文段或段。</li>\n<li><strong>对失序数据包重新排序以及去重</strong>：TCP 为了保证不发生丢包，就给每个包一个序列号，有了序列号能够将接收到的数据根据序列号排序，并且去掉重复序列号的数据就可以实现数据包去重。</li>\n<li><strong>校验和 : TCP 将保持它首部和数据的检验和</strong>。这是一个端到端的检验和，目的是检测数据在传输过程中的任何变化。如果收到段的检验和有差错，TCP 将丢弃这个报文段和不确认收到此报文段。</li>\n<li><strong>重传机制</strong> : 在数据包丢失或延迟的情况下，重新发送数据包，直到收到对方的确认应答（ACK）。TCP 重传机制主要有：基于计时器的重传（也就是超时重传）、快速重传（基于接收端的反馈信息来引发重传）、SACK（在快速重传的基础上，返回最近收到的报文段的序列号范围，这样客户端就知道，哪些数据包已经到达服务器了）、D-SACK（重复 SACK，在 SACK 的基础上，额外携带信息，告知发送方有哪些数据包自己重复接收了）。关于重传机制的详细介绍，可以查看详解 TCP 超时与重传机制这篇文章。</li>\n<li><strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。TCP 使用的流量控制协议是可变大小的滑动窗口协议（TCP 利用滑动窗口实现流量控制）。</li>\n<li><strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。TCP 在发送数据的时候，需要考虑两个因素：一是接收方的接收能力，二是网络的拥塞程度。接收方的接收能力由滑动窗口表示，表示接收方还有多少缓冲区可以用来接收数据。网络的拥塞程度由拥塞窗口表示，它是发送方根据网络状况自己维护的一个值，表示发送方认为可以在网络中传输的数据量。发送方发送数据的大小是滑动窗口和拥塞窗口的最小值，这样可以保证发送方既不会超过接收方的接收能力，也不会造成网络的过度拥塞。</li>\n</ol>\n<h2 id=\"1-4-TCP-如何实现流量控制？\"><a href=\"#1-4-TCP-如何实现流量控制？\" class=\"headerlink\" title=\"1.4 TCP 如何实现流量控制？\"></a>1.4 TCP 如何实现流量控制？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>发的太快， 接收方处理不过来&#x3D;&gt;先放缓冲区&#x3D;&gt;缓冲区满了，只能丢，浪费。</p></blockquote>\n<p><strong>TCP 利用滑动窗口实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。</strong> 接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为 0，则发送方不能发送数据。</p>\n<p><strong>为什么需要流量控制?</strong> 这是因为双方在通信的时候，发送方的速率与接收方的速率是不一定相等，如果发送方的发送速率太快，会导致接收方处理不过来。如果接收方处理不过来的话，就只能把处理不过来的数据存在 <strong>接收缓冲区(Receiving Buffers)</strong> 里（失序的数据包也会被存放在缓存区里）。如果缓存区满了发送方还在狂发数据的话，接收方只能把收到的数据包丢掉。出现丢包问题的同时又疯狂浪费着珍贵的网络资源。因此，我们需要控制发送方的发送速率，让接收方与发送方处于一种动态平衡才好。</p>\n<p>这里需要注意的是（常见误区）：</p>\n<ul>\n<li>发送端不等同于客户端</li>\n<li>接收端不等同于服务端</li>\n</ul>\n<p>TCP 为全双工(Full-Duplex, FDX)通信，双方可以进行双向通信，客户端和服务端既可能是发送端又可能是服务端。因此，两端各有一个发送缓冲区与接收缓冲区，两端都各自维护一个发送窗口和一个接收窗口。接收窗口大小取决于应用、系统、硬件的限制（TCP 传输速率不能大于应用的数据处理速率）。通信双方的发送窗口和接收窗口的要求相同</p>\n<p><strong>TCP 发送窗口可以把数据段划分成四个部分</strong>：</p>\n<ol>\n<li>已经发送并且确认的 TCP 段（已经发送并确认）；</li>\n<li>已经发送但是没有确认的 TCP 段（已经发送未确认）；</li>\n<li>未发送但是接收方准备接收的 TCP 段（可以发送）；</li>\n<li>未发送并且接收方也并未准备接受的 TCP 段（不可发送）。</li>\n</ol>\n<p><strong>TCP 发送窗口结构图示</strong>：</p>\n<p><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-send-window.png\" alt=\"TCP发送窗口结构\">TCP发送窗口结构</p>\n<ul>\n<li><strong>SND.WND</strong>：发送窗口。</li>\n<li><strong>SND.UNA</strong>：Send Unacknowledged 指针，指向发送窗口的第一个字节。</li>\n<li><strong>SND.NXT</strong>：Send Next 指针，指向可用窗口的第一个字节。</li>\n</ul>\n<p><strong>可用窗口大小</strong> &#x3D; <code>SND.UNA + SND.WND - SND.NXT</code> 。</p>\n<p><strong>TCP 接收窗口可以划分成三个部分</strong>：</p>\n<ol>\n<li>已经接收并且已经确认的 TCP 段（已经接收并确认）；</li>\n<li>等待接收且允许发送方发送 TCP 段（可以接收未确认）；</li>\n<li>不可接收且不允许发送方发送 TCP 段（不可接收）。</li>\n</ol>\n<p><strong>TCP 接收窗口结构图示</strong>：</p>\n<p><img src=\"https://oss.javaguide.cn/github/javaguide/cs-basics/network/tcp-receive-window.png\" alt=\"TCP接收窗口结构\">TCP接收窗口结构</p>\n<p><strong>接收窗口的大小是根据接收端处理数据的速度动态调整的。</strong> 如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p>\n<p>另外，这里的滑动窗口大小只是为了演示使用，实际窗口大小通常会远远大于这个值。</p>\n<h2 id=\"1-5-TCP-的拥塞控制是怎么实现的？\"><a href=\"#1-5-TCP-的拥塞控制是怎么实现的？\" class=\"headerlink\" title=\"1.5 TCP 的拥塞控制是怎么实现的？\"></a>1.5 TCP 的拥塞控制是怎么实现的？</h2><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。拥塞控制就是为了防止过多的数据注入到网络中，这样就可以使网络中的路由器或链路不致过载。拥塞控制所要做的都有一个前提，就是网络能够承受现有的网络负荷。拥塞控制是一个全局性的过程，涉及到所有的主机，所有的路由器，以及与降低网络传输性能有关的所有因素。相反，流量控制往往是点对点通信量的控制，是个端到端的问题。流量控制所要做到的就是抑制发送端发送数据的速率，以便使接收端来得及接收。</p></blockquote>\n<p>为了进行拥塞控制，TCP 发送方要维持一个 <strong>拥塞窗口(cwnd)</strong> 的状态变量。拥塞控制窗口的大小取决于网络的拥塞程度，并且动态变化。发送方让自己的发送窗口取为拥塞窗口和接收方的接受窗口中较小的一个。</p>\n<p>TCP 的拥塞控制采用了四种算法，即 <strong>慢开始</strong>、 <strong>拥塞避免</strong>、<strong>快重传</strong> 和 <strong>快恢复</strong>。在网络层也可以使路由器采用适当的分组丢弃策略（如主动队列管理 AQM），以减少网络拥塞的发生。</p>\n<ul>\n<li><strong>慢开始：</strong> 慢开始算法的思路是当主机开始发送数据时，如果立即把大量数据字节注入到网络，那么可能会引起网络阻塞，因为现在还不知道网络的符合情况。经验表明，较好的方法是先探测一下，即由小到大逐渐增大发送窗口，也就是由小到大逐渐增大拥塞窗口数值。cwnd 初始值为 1，每经过一个传播轮次，cwnd 加倍。</li>\n<li><strong>拥塞避免：</strong> 拥塞避免算法的思路是让拥塞窗口 cwnd 缓慢增大，即每经过一个往返时间 RTT 就把发送方的 cwnd 加 1.</li>\n<li><strong>快重传与快恢复：</strong> 在 TCP&#x2F;IP 中，快速重传和恢复（fast retransmit and recovery，FRR）是一种拥塞控制算法，它能快速恢复丢失的数据包。没有 FRR，如果数据包丢失了，TCP 将会使用定时器来要求传输暂停。在暂停的这段时间内，没有新的或复制的数据包被发送。有了 FRR，如果接收机接收到一个<strong>不按顺序</strong>的数据段，它会立即<strong>给发送机发送一个重复确认</strong>。如果<strong>发送机接收到三个重复确认</strong>，它会假定确认件指出的<strong>数据段</strong>丢失了，并<strong>立即重传</strong>这些丢失的数据段。有了 FRR，就不会因为重传时要求的暂停被耽误。当有单独的数据包丢失时，快速重传和恢复（FRR）能最有效地工作。当有多个数据信息包在某一段很短的时间内丢失时，它则不能很有效地工作。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><ol>\n<li><strong>慢启动（Slow Start）</strong>：当一条TCP连接开始传输数据时，它不会立即以最大速度发送数据，因为这样做可能会立即使网络拥塞。慢启动算法的目的是通过逐渐增加发送数据的速率来探测网络的承载能力。起初，TCP连接的拥塞窗口（cwnd）大小很小，每当收到一个ACK，cwnd就增加，导致数据传输率指数级增长，直到达到一个阈值（ssthresh）。</li>\n<li><strong>拥塞避免（Congestion Avoidance）</strong>：当cwnd达到或超过ssthresh时，TCP进入拥塞避免阶段。在这个阶段，cwnd的增长转为线性增长，即每经过一个往返时间（RTT），cwnd增加1个MSS的大小（MSS：最大段大小）。这样做是为了避免网络拥塞。</li>\n<li><strong>快速重传（Fast Retransmit）</strong>：当发送方收到三个重复的ACK时，它推断出一个段很可能已经丢失，于是不等待重传计时器到期，立即重传丢失的段。</li>\n<li><strong>快速恢复（Fast Recovery）</strong>：在执行快速重传之后，TCP执行快速恢复算法。在快速恢复阶段，TCP将ssthresh设置为当前拥塞窗口的一半，cwnd设置为ssthresh加上重复ACK的数量，然后开始线性增加cwnd，直到再次遇到丢包为止。</li>\n</ol></blockquote>\n<h2 id=\"1-6-HTTP-1-0-和-HTTP-1-1的区别\"><a href=\"#1-6-HTTP-1-0-和-HTTP-1-1的区别\" class=\"headerlink\" title=\"1.6 HTTP&#x2F;1.0  和 HTTP&#x2F;1.1的区别\"></a>1.6 HTTP&#x2F;1.0  和 HTTP&#x2F;1.1的区别</h2>","feature":true,"text":"1. 计算机网络 看了不下三四十份面经，所有部分都属于必问。 文章内容 基于 Javaguide.cn 提供的资料，进行整合和总结。 著作权归JavaGuide...","permalink":"/post/面试准备","photos":[],"count_time":{"symbolsCount":"8.6k","symbolsTime":"8 mins."},"categories":[{"name":"实习","slug":"实习","count":1,"path":"api/categories/实习.json"}],"tags":[{"name":"面试准备","slug":"面试准备","count":1,"path":"api/tags/面试准备.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#1-%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C\"><span class=\"toc-text\">1. 计算机网络</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-1-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E5%92%8C%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%88%E4%BC%A0%E8%BE%93%E5%B1%82%EF%BC%89\"><span class=\"toc-text\">1.1 TCP 三次握手和四次挥手（传输层）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-1-%E5%BB%BA%E7%AB%8B%E8%BF%9E%E6%8E%A5-TCP-%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B\"><span class=\"toc-text\">1.1.1 建立连接-TCP 三次握手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-1-1-%E7%AC%AC-2-%E6%AC%A1%E6%8F%A1%E6%89%8B%E4%BC%A0%E5%9B%9E%E4%BA%86-ACK%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E4%BC%A0%E5%9B%9E-SYN%EF%BC%9F\"><span class=\"toc-text\">1.1.1.1 第 2 次握手传回了 ACK，为什么还要传回 SYN？</span></a></li></ol></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-1-2-%E6%96%AD%E5%BC%80%E8%BF%9E%E6%8E%A5-TCP-%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B\"><span class=\"toc-text\">1.1.2 断开连接-TCP 四次挥手</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-2-1-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F\"><span class=\"toc-text\">1.1.2.1 为什么要四次挥手？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-2-2-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E8%83%BD%E6%8A%8A%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%8F%91%E9%80%81%E7%9A%84-ACK-%E5%92%8C-FIN-%E5%90%88%E5%B9%B6%E8%B5%B7%E6%9D%A5%EF%BC%8C%E5%8F%98%E6%88%90%E4%B8%89%E6%AC%A1%E6%8C%A5%E6%89%8B%EF%BC%9F\"><span class=\"toc-text\">1.1.2.2 为什么不能把服务器发送的 ACK 和 FIN 合并起来，变成三次挥手？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-2-3-%E5%A6%82%E6%9E%9C%E7%AC%AC%E4%BA%8C%E6%AC%A1%E6%8C%A5%E6%89%8B%E6%97%B6%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%9A%84-ACK-%E6%B2%A1%E6%9C%89%E9%80%81%E8%BE%BE%E5%AE%A2%E6%88%B7%E7%AB%AF%EF%BC%8C%E4%BC%9A%E6%80%8E%E6%A0%B7%EF%BC%9F\"><span class=\"toc-text\">1.1.2.3 如果第二次挥手时服务器的 ACK 没有送达客户端，会怎样？</span></a></li><li class=\"toc-item toc-level-4\"><a class=\"toc-link\" href=\"#1-1-2-4-%E4%B8%BA%E4%BB%80%E4%B9%88%E7%AC%AC%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E5%AE%A2%E6%88%B7%E7%AB%AF%E9%9C%80%E8%A6%81%E7%AD%89%E5%BE%85-2-MSL%EF%BC%88%E6%8A%A5%E6%96%87%E6%AE%B5%E6%9C%80%E9%95%BF%E5%AF%BF%E5%91%BD%EF%BC%89%E6%97%B6%E9%97%B4%E5%90%8E%E6%89%8D%E8%BF%9B%E5%85%A5-CLOSED-%E7%8A%B6%E6%80%81%EF%BC%9F\"><span class=\"toc-text\">1.1.2.4 为什么第四次挥手客户端需要等待 2*MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</span></a></li></ol></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-2-HTTP-vs-HTTPS%EF%BC%88%E5%BA%94%E7%94%A8%E5%B1%82%EF%BC%89\"><span class=\"toc-text\">1.2 HTTP vs HTTPS（应用层）</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-1-HTTP-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1.2.1 HTTP 协议介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-2-HTTP-%E9%80%9A%E4%BF%A1%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">1.2.2  HTTP 通信流程</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-3-HTTP-%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">1.2.3 HTTP 优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-4-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BB%8B%E7%BB%8D\"><span class=\"toc-text\">1.2.4 HTTPS 协议介绍</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-5-HTTPS-%E5%8D%8F%E8%AE%AE%E4%BC%98%E7%82%B9\"><span class=\"toc-text\">1.2.5 HTTPS 协议优点</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-6-HTTPS-%E7%9A%84%E6%A0%B8%E5%BF%83%E2%80%94SSL-TLS-%E5%8D%8F%E8%AE%AE\"><span class=\"toc-text\">1.2.6 HTTPS 的核心—SSL&#x2F;TLS 协议</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#1-2-6-1-SSL-%E5%92%8C-TLS-%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F\"><span class=\"toc-text\">1.2.6.1 SSL 和 TLS 的区别？</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-3-TCP-%E5%A6%82%E4%BD%95%E4%BF%9D%E8%AF%81%E4%BC%A0%E8%BE%93%E7%9A%84%E5%8F%AF%E9%9D%A0%E6%80%A7%EF%BC%9F\"><span class=\"toc-text\">1.3 TCP 如何保证传输的可靠性？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-4-TCP-%E5%A6%82%E4%BD%95%E5%AE%9E%E7%8E%B0%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%EF%BC%9F\"><span class=\"toc-text\">1.4 TCP 如何实现流量控制？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-5-TCP-%E7%9A%84%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E6%98%AF%E6%80%8E%E4%B9%88%E5%AE%9E%E7%8E%B0%E7%9A%84%EF%BC%9F\"><span class=\"toc-text\">1.5 TCP 的拥塞控制是怎么实现的？</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#1-6-HTTP-1-0-%E5%92%8C-HTTP-1-1%E7%9A%84%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">1.6 HTTP&#x2F;1.0  和 HTTP&#x2F;1.1的区别</span></a></li></ol></li></ol>","author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}},"mapped":true,"hidden":false,"prev_post":{},"next_post":{"title":"","uid":"f73a8e23e6f6f669cf99c7dba8fa0722","slug":"Docker","date":"2024-04-06T16:43:16.409Z","updated":"2024-04-06T16:43:16.409Z","comments":true,"path":"api/articles/Docker.json","keywords":"Kangwei Zhu's Blog","cover":null,"text":"","permalink":"/post/Docker","photos":[],"count_time":{"symbolsCount":0,"symbolsTime":"1 mins."},"categories":[],"tags":[],"author":{"name":"Kangwei Zhu","slug":"blog-author","avatar":"https://avatars.githubusercontent.com/u/93107633?v=4","link":"/","description":"偏我来时不逢春，偏我去时春满城","socials":{"github":"https://github.com/KangweiZhu","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"leetcode":{"icon":"/svg/leetcode-svgrepo-com.svg","link":"https://leetcode.com/anicaaovo/"}}}},"feature":true}}