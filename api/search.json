[{"id":"e3d52c82ec9d0e397162fdf9ef9d2323","title":"Lyrics On Panel -- KDE/PLASMA5下基于QML + MPRIS2的 菜单栏/桌面/任务栏 歌词小组件的开发","content":"0. 前言\n\n\n\n\n\n\n\n\n使用 ArchLinux 以及 Manjaro 这两个kde下的系统时，窗体以及桌面效果其实已经能够几乎完美的模仿macOS了。唯一觉得很尴尬的就是Linux下的播放器，做不到和mac下一样，在菜单栏中显示歌词和切歌（实际上是有好几个轮子组合起来是能够做到差不多效果的）。比如\n\nYesPlayMusic的歌词组件 https://github.com/zsiothsu/org.kde.plasma.yesplaymusic-lyrics \n显示正在播放的歌曲的 歌名丨歌手名 https://github.com/JunoNgx/kde-currently-playing\n媒体控制（前进，后退，暂停，etc.）https://github.com/panagiotopoulos/MediaBar/\nKDE Media Controller &#x2F;usr&#x2F;share&#x2F;plasma&#x2F;plasmoids&#x2F;org.kde.plasma.mediacontroller但是这几个组件组合起来之后，样式挺奇怪的，不够integrated。而且多多少少有点bug。\n\n所以打算写一款在能够在 plasma panel 中能够 显示歌词 和 控制音乐播放 的小组件。最后效果应该长这样子。\n\n​\t\n最后感谢上面四个repo的作者们。本组件的开发参考了你们的部分实现思路。\n项目源码： https://github.com/KangweiZhu/lyrics-on-panel\nKde Store地址： https://store.kde.org/p/2138263\n1. 项目结构根据https://develop.kde.org/docs/plasma/widget/setup/，qml widget项目结构应该是这样子的\ntxt└── ~/Code/plasmoid-helloworld/\n    └── package\n        ├── contents\n        │   ├── ui\n        │   │   ├── main.qml\n        │   │   └── configGeneral.qml\n        │   └── config\n        │       ├── config.qml\n        │       └── main.xml\n        └── metadata.json但是你可以先这样子创建你的目录。\nedit: 就算你要上传到kde store, 也是用以下这个目录形式。\n└── ~&#x2F;Code&#x2F;plasmoid-helloworld&#x2F;   ├── contents    │   ├── ui    │   │   ├── main.qml    │   │   └── configGeneral.qml    │   └── config    │       ├── config.qml    │       └── main.xml   └── metadata.json\n2. 如何找到系统自带组件和你已经下载的组件系统自带组件在/usr/share/plasma/plasmoids/里面\n下载的组件/home/你的用户名/.local/share/plasma/plasmoids\n由于kde关于组件开发的文档其实不是很全，所以可以将这些自带的组建作为参考资料。\n3. 调试组件有三种可用调试工具。同样在kde文档上写了。具体了解可以去看“Testing”部分。这里推荐使用plasmoidviewer, 需要在pamac中下载，并下载其依赖。\nbashplasmoidviewer -a /home/anicaa/.local/share/plasma/plasmoids/org.kde.plasma.lyrics-on-panel替换成你的项目路径就可以\n\n当然，我们也可以直接在目前的plasma panel上调试。\n\n删除已安装的本插件（如果安装过了的话）\n\nbashkpackagetool5 -t Plasma/Applet -r /home/anicaa/文档/com.github.KangweiZhu.lyrics-on-panel-plasma5 \n安装本插件\n\ntxtkpackagetool5 -t Plasma/Applet -i /home/anicaa/文档/com.github.KangweiZhu.lyrics-on-panel-plasma5\n\n重启panel\n\nbashplasmashell --replace 4. mpris2\n\n\n\n\n\n\n\n\nRef: https://www.freedesktop.org/wiki/Specifications/mpris-spec/metadata/\nhttps://readthedocs.org/projects/mpris2/downloads/pdf/latest/\n只用这个。本地的媒体数据源。\n在console中查看所有信息。\ntxt//main.qml\nimport QtQuick 2.0\nimport org.kde.plasma.core 2.0 as PlasmaCore\n\nItem &#123;\n    PlasmaCore.DataSource &#123;\n        id: mpris2Source\n        engine: &quot;mpris2&quot;\n        connectedSources: sources\n        interval: 100  // Polling interval in milliseconds.\n\n        readonly property var multiplex: data[&quot;@multiplex&quot;]\n\n        onDataChanged: &#123;\n            console.log(&quot;Data changed!&quot;);\n            for (var key in mpris2Source.data) &#123;\n                console.log(key + &quot;: &quot; + JSON.stringify(mpris2Source.data[key]));\n            &#125;\n        &#125;\n    &#125;\n&#125;bashqml: @multiplex: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.263Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;Source Name&quot;:&quot;yesplaymusic&quot;,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: chromium.instance2616: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:false,&quot;CanGoPrevious&quot;:false,&quot;CanPause&quot;:false,&quot;CanPlay&quot;:false,&quot;CanQuit&quot;:false,&quot;CanRaise&quot;:false,&quot;CanSeek&quot;:false,&quot;Identity&quot;:&quot;Chrome&quot;,&quot;InstancePid&quot;:2616,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:album&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Stopped&quot;,&quot;Position&quot;:0,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:1&#125;\nqml: yesplaymusic: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.263Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: objectNameChanged: undefined\nqml: valueChanged: undefined\nqml: keys: undefined\nqml: __0: undefined\nqml: __1: undefined\nqml: __2: undefined\nkde.dataengine.mpris: &quot;org.mpris.MediaPlayer2.chromium.instance2616&quot; has an invalid URL for the mpris:artUrl entry of the &quot;Metadata&quot; property\nqml: Data changed!\nqml: objectName: &quot;&quot;\nqml: @multiplex: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;Source Name&quot;:&quot;yesplaymusic&quot;,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: chromium.instance2616: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:false,&quot;CanGoPrevious&quot;:false,&quot;CanPause&quot;:false,&quot;CanPlay&quot;:false,&quot;CanQuit&quot;:false,&quot;CanRaise&quot;:false,&quot;CanSeek&quot;:false,&quot;Identity&quot;:&quot;Chrome&quot;,&quot;InstancePid&quot;:2616,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:album&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Stopped&quot;,&quot;Position&quot;:0,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:1&#125;\nqml: yesplaymusic: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.263Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: objectNameChanged: undefined\nqml: valueChanged: undefined\nqml: keys: undefined\nqml: __0: undefined\nqml: __1: undefined\nqml: __2: undefined\nqml: Data changed!\nqml: objectName: &quot;&quot;\nqml: @multiplex: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;Source Name&quot;:&quot;yesplaymusic&quot;,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: chromium.instance2616: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:false,&quot;CanGoPrevious&quot;:false,&quot;CanPause&quot;:false,&quot;CanPlay&quot;:false,&quot;CanQuit&quot;:false,&quot;CanRaise&quot;:false,&quot;CanSeek&quot;:false,&quot;Identity&quot;:&quot;Chrome&quot;,&quot;InstancePid&quot;:2616,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:album&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Stopped&quot;,&quot;Position&quot;:0,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:1&#125;\nqml: yesplaymusic: &#123;&quot;CanControl&quot;:true,&quot;CanGoNext&quot;:true,&quot;CanGoPrevious&quot;:true,&quot;CanPause&quot;:true,&quot;CanPlay&quot;:true,&quot;CanQuit&quot;:true,&quot;CanRaise&quot;:true,&quot;CanSeek&quot;:true,&quot;DesktopEntry&quot;:&quot;&quot;,&quot;Fullscreen&quot;:false,&quot;Identity&quot;:&quot;YesPlayMusic&quot;,&quot;InstancePid&quot;:58382,&quot;LoopStatus&quot;:&quot;None&quot;,&quot;MaximumRate&quot;:1,&quot;Metadata&quot;:&#123;&quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,&quot;mpris:length&quot;:431000000,&quot;mpris:trackid&quot;:&quot;&quot;,&quot;xesam:artist&quot;:[&quot;&quot;],&quot;xesam:title&quot;:&quot;沈园外0.9&quot;&#125;,&quot;MinimumRate&quot;:1,&quot;PlaybackStatus&quot;:&quot;Paused&quot;,&quot;Position&quot;:132568986,&quot;Position last updated (UTC)&quot;:&quot;2024-03-07T11:27:25.364Z&quot;,&quot;Rate&quot;:1,&quot;Shuffle&quot;:false,&quot;SupportedMimeTypes&quot;:[],&quot;SupportedUriSchemes&quot;:[],&quot;Volume&quot;:0&#125;\nqml: objectNameChanged: undefined\nqml: valueChanged: undefined\nqml: keys: undefined\nqml: __0: undefined\nqml: __1: undefined\nqml: __2: undefined\n^C看上去乱糟糟的。我们用gpt给他整理一下。\ntxt@multiplex：&#123;\n  &quot;CanControl&quot;: true,\n  &quot;CanGoNext&quot;: true,\n  &quot;CanGoPrevious&quot;: true,\n  &quot;CanPause&quot;: true,\n  &quot;CanPlay&quot;: true,\n  &quot;CanQuit&quot;: true,\n  &quot;CanRaise&quot;: true,\n  &quot;CanSeek&quot;: true,\n  &quot;DesktopEntry&quot;: &quot;&quot;,\n  &quot;Fullscreen&quot;: false,\n  &quot;Identity&quot;: &quot;YesPlayMusic&quot;,\n  &quot;InstancePid&quot;: 58382,\n  &quot;LoopStatus&quot;: &quot;None&quot;,\n  &quot;MaximumRate&quot;: 1,\n  &quot;Metadata&quot;: &#123;\n    &quot;mpris:artUrl&quot;: &quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,\n    &quot;mpris:length&quot;: 431000000,\n    &quot;mpris:trackid&quot;: &quot;&quot;,\n    &quot;xesam:artist&quot;: [&quot;&quot;],\n    &quot;xesam:title&quot;: &quot;沈园外0.9&quot;\n  &#125;,\n  &quot;MinimumRate&quot;: 1,\n  &quot;PlaybackStatus&quot;: &quot;Paused&quot;,\n  &quot;Position&quot;: 132568986,\n  &quot;Position last updated (UTC)&quot;: &quot;2024-03-07T11:27:25.364Z&quot;,\n  &quot;Rate&quot;: 1,\n  &quot;Shuffle&quot;: false,\n  &quot;Source Name&quot;: &quot;yesplaymusic&quot;,\n  &quot;SupportedMimeTypes&quot;: [],\n  &quot;SupportedUriSchemes&quot;: [],\n  &quot;Volume&quot;: 0\n&#125;txtchromium.instance2616: &#123;\n  &quot;CanControl&quot;: true,\n  &quot;CanGoNext&quot;: false,\n  &quot;CanGoPrevious&quot;: false,\n  &quot;CanPause&quot;: false,\n  &quot;CanPlay&quot;: false,\n  &quot;CanQuit&quot;: false,\n  &quot;CanRaise&quot;: false,\n  &quot;CanSeek&quot;: false,\n  &quot;Identity&quot;: &quot;Chrome&quot;,\n  &quot;InstancePid&quot;: 2616,\n  &quot;MaximumRate&quot;: 1,\n  &quot;Metadata&quot;: &#123;\n    &quot;mpris:trackid&quot;: &quot;&quot;,\n    &quot;xesam:album&quot;: &quot;&quot;,\n    &quot;xesam:artist&quot;: [&quot;&quot;],\n    &quot;xesam:title&quot;: &quot;&quot;\n  &#125;,\n  &quot;MinimumRate&quot;: 1,\n  &quot;PlaybackStatus&quot;: &quot;Stopped&quot;,\n  &quot;Position&quot;: 0,\n  &quot;Position last updated (UTC)&quot;: &quot;2024-03-07T11:27:25.364Z&quot;,\n  &quot;Rate&quot;: 1,\n  &quot;SupportedMimeTypes&quot;: [],\n  &quot;SupportedUriSchemes&quot;: [],\n  &quot;Volume&quot;: 1\n&#125;\ntxtyesplaymusic&#123;\n  &quot;CanControl&quot;: true,\n  &quot;CanGoNext&quot;: true,\n  &quot;CanGoPrevious&quot;: true,\n  &quot;CanPause&quot;: true,\n  &quot;CanPlay&quot;: true,\n  &quot;CanQuit&quot;: true,\n  &quot;CanRaise&quot;: true,\n  &quot;CanSeek&quot;: true,\n  &quot;DesktopEntry&quot;: &quot;&quot;,\n  &quot;Fullscreen&quot;: false,\n  &quot;Identity&quot;: &quot;YesPlayMusic&quot;,\n  &quot;InstancePid&quot;: 58382,\n  &quot;LoopStatus&quot;: &quot;None&quot;,\n  &quot;MaximumRate&quot;: 1,\n  &quot;Metadata&quot;: &#123;\n    &quot;mpris:artUrl&quot;: &quot;https://p1.music.126.net/UeTuwE7pvjBpypWLudqukA==/3132508627578625.jpg?param=224y224&quot;,\n    &quot;mpris:length&quot;: 431000000,\n    &quot;mpris:trackid&quot;: &quot;&quot;,\n    &quot;xesam:artist&quot;: [&quot;&quot;],\n    &quot;xesam:title&quot;: &quot;沈园外0.9&quot;\n  &#125;,\n  &quot;MinimumRate&quot;: 1,\n  &quot;PlaybackStatus&quot;: &quot;Paused&quot;,\n  &quot;Position&quot;: 132568986,\n  &quot;Position last updated (UTC)&quot;: &quot;2024-03-07T11:27:25.364Z&quot;,\n  &quot;Rate&quot;: 1,\n  &quot;Shuffle&quot;: false,\n  &quot;SupportedMimeTypes&quot;: [],\n  &quot;SupportedUriSchemes&quot;: [],\n  &quot;Volume&quot;: 0\n&#125;\n注意这三个是同级的，也就是说我们目前本地的媒体datasource中，存在这三个源。即：\n&quot;Identity&quot;: &quot;YesPlayMusic&quot;,\n&quot;Identity&quot;: &quot;Chrome&quot;,\n&quot;Identity&quot;: &quot;YesPlayMusic&quot;,\n\n\n\n\n\n\n\n\n\n没有具体的去了解multiplex在这里指的是什么，但是很明显应该是正在播放的东西。所以我们后续，可以通过这个identity来区分，正在播放来自哪个播放器的音乐。做字符串判断就可以了。Spotify, VLC, Elisa, YesPlayMusic. 不同的播放器有不同的歌词获取逻辑。但是歌词处理是一样的。\n另外一个非常重要的数据是&quot;Position&quot;: 132568986,这个就是当前播放的进度。我们在播放器中调进度，当前的值都可以通过这个获取到。\n上面的json中的MetaData部分有些缺失，这个例子应该是全的\njson&quot;Metadata&quot;: &#123; &quot;mpris:artUrl&quot;:&quot;https://p1.music.126.net/vcjmAMkqTeW_KReRQSXavA==/18568552371851739.jpg?param=224y224&quot;,&quot;\nmpris:length&quot;:234000000, //长度\n&quot;mpris:trackid&quot;:&quot;&quot;, \n&quot;xesam:album&quot;:&quot;雀跃&quot;, //专辑\n&quot;xesam:artist&quot;:[&quot;任然&quot;,&quot;小来&quot;], //歌手\n&quot;xesam:title&quot;:&quot;雀跃&quot; //歌名 \n&#125;\n\n注意artist是一个list,所以要用toString()来转换结果。其余都是string\n5. QML5.1 Text\n\n\n\n\n\n\n\n\nhttps://doc.qt.io/qt-5/qml-qtquick-text.html\n重点在于\n\n*contentHeight* : real\n*contentWidth* : real\n\n这两个属性。因为歌词，歌曲信息的长度是动态可变的。所以我们整个 歌词&amp;歌曲容器的长度（宽度）也得变。不然整个组件在panel上的布局就会很怪异。\n当然，还有一种更聪明、稳定的做法。 我们可以固定Item(歌词容器)的长度。然后判断当前Text的长度，如果Text大于歌词容器的长度，那就变成滚动地显示本行Text，一行内滚完该Text的内容。如果Text小于歌词容器的长度，那就老样子，还是一行一行的显示。我们为了简单，目前就不做了。后续考虑加一下这个功能，和歌词的动效。\n5.2 Plasma Widget Tutorial5.2.1 Plasmoid.fullRepresentation这个必须设Plasmoid.preferredRepresentation: Plasmoid.fullRepresentation \n否则就是显示一个你的icon，需要点击icon才会显示具体的内容。很明显不是我们想要的。\nkde是这样解释的：\n\n\n\n\n\n\n\n\n\nPlasmoid.compactRepresentation (with a capital) and Plasmoid.fullRepresentation are used to define the layout of the small “icon” view and the full “popup” view. These are both properties of the main Item. If neither are set, by default the main Item is the full representation.\n5.3 Configuration\n\n\n\n\n\n\n\n\n项目配置\n5.3.1 Kirigami2\n\n\n\n\n\n\n\n\nAPI: https://api.kde.org/frameworks/kirigami/html/index.html\n项目里主要用到FormLayout.\n\n\n\n\n\n\n\n\n\nFormLayout API: https://api.kde.org/frameworks/kirigami/html/classFormLayout.html\n6. 歌词源\n\n\n\n\n\n\n\n\nThanks to this source: ref:  https://github.com/SimonIT/spotifylyrics/blob/master/README.md\n\nrentanadviser.com (synchronized)\nmegalobiz.com (synchronized)\nlyricsify.com (synchronized) \nrclyricsband.com (synchronized)\nmusixmatch.com\nsongmeanings.com\nsonglyrics.com\ngenius.com\nversuri.ro\nAZLyrics.com\n\n都是可以用的。musixmatch应该是最好最全的，但是api需要付费。然后具体定价也没说。lyricsify英文歌也比较全，但是有Cloudfare保护，我们fetch不到歌词。\n这个好用。免费api， 无rate limit. 唯一缺点英文歌很全，中文歌几乎没有。可以使用&#x2F;api&#x2F;publish来上传歌词。本组件会在使用yesplaymusic的时候自动往lrclib上传中文歌曲信息。\n\n\n\n\n\n\n\n\n\nThanks to this sourcehttps://github.com/tranxuanthang/lrcget\ntxthttps://lrclib.net/docstxt[\n    &#123;\n        &quot;id&quot;: 6057484,\n        &quot;name&quot;: &quot;告白氣球&quot;,\n        &quot;trackName&quot;: &quot;告白氣球&quot;,\n        &quot;artistName&quot;: &quot;Jay Chou&quot;,\n        &quot;albumName&quot;: &quot;周杰倫的床邊故事&quot;,\n        &quot;duration&quot;: 216,\n        &quot;instrumental&quot;: false,\n        &quot;plainLyrics&quot;: &quot;告白氣球\\n\\n塞納河畔 左岸的咖啡\\n我手一杯 品嚐你的美\\n留下唇印的嘴 whoa\\n\\n花店玫瑰 名字寫錯誰?\\n告白氣球 風吹到對街\\n微笑在天上飛 (該你們)\\n\\n你說你有點難追 想讓我知難而退\\n禮物不需挑最貴 只要香榭的落葉\\n營造浪漫的約會 不害怕搞砸一切\\n擁有你就擁有 全世界\\n\\n親愛的 愛上你 從那天起\\n甜蜜的很輕易 whoa\\n親愛的 別任性 你的眼睛\\n在說我願意\\n\\n下面的朋友準備好了嗎?\\n\\n塞納河畔 左岸的咖啡\\n我手一杯 品嚐你的美\\n留下唇印的嘴 whoo\\n\\n花店玫瑰 名字寫錯誰?\\n告白氣球 風吹到對街\\n微笑在天上飛 whoa\\n\\n你說你有點難追 想讓我知難而退\\n禮物不需挑最貴 只要香榭的落葉\\n營造浪漫的約會 不害怕搞砸一切\\n擁有你就擁有 全世界\\n\\n親愛的 愛上你 從那天起\\n甜蜜的很輕易\\n親愛的 別任性 你的眼睛\\n在說我願意\\n\\n親愛的 愛上你 戀愛日記\\n飄香水的回憶 whoa\\n一整瓶 的夢境 全都有你\\n攪拌在一起\\n\\n親愛的別任性 你的眼睛\\n在說我願意\\n謝謝\\n\\n(親愛的 愛上你 從那天起)\\n(甜蜜的很輕易)\\n(親愛的 別任性 你的眼睛)\\n(在說我願意)&quot;,\n        &quot;syncedLyrics&quot;: &quot;[00:03.26] 告白氣球\\n[00:23.75] 塞納河畔 左岸的咖啡\\n[00:26.64] 我手一杯 品嚐你的美\\n[00:29.70] 留下唇印的嘴 whoa\\n[00:34.76] 花店玫瑰 名字寫錯誰?\\n[00:37.22] 告白氣球 風吹到對街\\n[00:40.47] 微笑在天上飛 (該你們)\\n[00:44.44] 你說你有點難追 想讓我知難而退\\n[00:49.89] 禮物不需挑最貴 只要香榭的落葉\\n[00:54.92] 營造浪漫的約會 不害怕搞砸一切\\n[01:00.45] 擁有你就擁有 全世界\\n[01:05.43] 親愛的 愛上你 從那天起\\n[01:11.71] 甜蜜的很輕易 whoa\\n[01:16.36] 親愛的 別任性 你的眼睛\\n[01:22.46] 在說我願意\\n[01:28.55] 下面的朋友準備好了嗎?\\n[01:49.21] 塞納河畔 左岸的咖啡\\n[01:52.27] 我手一杯 品嚐你的美\\n[01:55.22] 留下唇印的嘴 whoo\\n[01:59.99] 花店玫瑰 名字寫錯誰?\\n[02:02.63] 告白氣球 風吹到對街\\n[02:05.82] 微笑在天上飛 whoa\\n[02:09.77] 你說你有點難追 想讓我知難而退\\n[02:14.99] 禮物不需挑最貴 只要香榭的落葉\\n[02:20.30] 營造浪漫的約會 不害怕搞砸一切\\n[02:25.81] 擁有你就擁有 全世界\\n[02:30.82] 親愛的 愛上你 從那天起\\n[02:37.12] 甜蜜的很輕易\\n[02:41.71] 親愛的 別任性 你的眼睛\\n[02:47.69] 在說我願意\\n[02:52.26] 親愛的 愛上你 戀愛日記\\n[02:58.46] 飄香水的回憶 whoa\\n[03:03.05] 一整瓶 的夢境 全都有你\\n[03:09.12] 攪拌在一起\\n[03:13.78] 親愛的別任性 你的眼睛\\n[03:22.11] 在說我願意\\n[03:28.12] 謝謝\\n[03:29.65] (親愛的 愛上你 從那天起)\\n[03:29.94] (甜蜜的很輕易)\\n[03:30.51] (親愛的 別任性 你的眼睛)\\n[03:31.16] (在說我願意)\\n[03:33.88] &quot;\n    &#125; \n]7.XHR发http请求。没啥好说的，就是JS. 不要让数据太依赖异步方法的更新，不然容易出奇怪的bug.\n8. 精度问题txtqml: current song time 1.0579999999999943\nqml: current song time 1.0589999999999942\nqml: current song time 1.059999999999994\nqml: current song time 1.060999999999994\nqml: current song time 1.0619999999999938\nqml: current song time 1.0629999999999937\nqml: current song time 1.0639999999999936\nqml: current song time 1.0649999999999935\nqml: current song time 1.0659999999999934\nqml: current song time 1.0669999999999933\nqml: current song time 1.0679999999999932\nqml: current song time 1.068999999999993\nqml: current song time 1.069999999999993\nqml: current song time 1.07099999999999289. 图标网易云音乐图标: https://www.svgrepo.com/svg/346157/netease-cloud-music-fill\n暂停，上一首，下一首: https://thenounproject.com/browse/icons/term/play-back/\n这个的网易云图标似乎更好https://icon-icons.com/icon/netease-cloud-music-logo/206716\n","slug":"Lyrics On Panel -- KDE PLASMA下基于QML的小组件的开发","date":"2024-03-04T17:50:10.959Z","categories_index":"Linux","tags_index":"Linux,QT,QML,KDE,Plasma,Arch,Manjaro","author_index":"Kangwei Zhu"},{"id":"c71ccdef1ed9d7776e2a0eeec0e84e3a","title":"Manjaro配置","content":"Manjaro配置\n\n\n\n\n\n\n\n\nKde Plasma6距离发布还有三天。Manjaro kde的graphic plaform已经从默认x11切换成wayland。先前使用Arch时，配置过程都是肉身在国外，从来没经历过国内这么麻烦的网络情况。所以再写一次，从零配置，美化Manjaro + kde plasma 5&#x2F;6 + wayland的笔记。\n0. 前言本篇笔记需要你具有：\n\n基本的Linux命令和文件系统结构知识\n使用谷歌进行搜索的技巧（site:: forum.manjaro.rog &amp; archlinux.org， etc.)\n基本的中英文和文档阅读能力\n机场\n试错的耐心\n\n1. 单硬盘Duo Boot\n\n\n\n\n\n\n\n\n首先吐槽一下，中文互联网上，装个linux动辄使用乱七八遭的磁盘软件进行分盘，mbr, gpt 分区换来换去, 还要留个efi分区。都2k24了，绝大多数系统用不着这样子折腾。Manjaro对双系统的优化很好，自身在系统安装时就能识别windows boot manager, 完全不需要担心grub消失， 显卡驱动安装异常等问题。\n唯一存在的问题就是 A+N时显卡功耗跑不满。\n安装系统按照下面的傻瓜式步骤就可以了。\n\n强烈建议重装windows。\n从微软官方下载win11镜像。\n从manjaro官方下载manjaro plasma版镜像。\n进入ventoy官网。下载ventoy.\n\n​\t注意：制作启动盘一定要在windows环境下制作。linux下制作启动盘时，windows iso会出问题。无论你想抹掉win, 只安装linux, 还是双系统，都建议提前做好windows的启动盘。\n\n需要一个大小在32G的u盘。\n将u盘插入usb接口，在ventoy中点击制作。\n制作完成后将win11镜像和manjaro镜像 iso都放进u盘。\n把需要备份、迁移的文件放进u盘。\n关机。\n进bios, 关闭secure&#x2F;fast boot。\n进bios,选择从u盘启动。\n进入ventoy界面，选择win11.iso\n开始重装win。删除你原先系统所占用的磁盘。然后分配一定空间新建磁盘，给win系统用。剩余空间变成未分配，留着给Manjaro用。\n一路点点点，完成win11设置，进入win11桌面后再重启。\n进bios, 选择从u盘启动。\n进入ventoy界面，选择manjaro.iso\n设置时区，语言后，n卡选择闭源，a卡选择开源。 boot with proprietary &#x2F; open source。\n进系统后，连wifi,然后点桌面唯一的图标。\n点点点，直到磁盘分区。，选择replace partition（应该叫这个。中文可能是替换xxx），点击之前磁盘上留下的未分配空间。确定。内存小于16gb的需要额外设置swap分区, 不然容易不去free就用着用着卡死。swap大小建议20gb。大于16gb则不用设置。\n设密码，设用户名，然后点点点，等进度条走完就会重启。\n重启后就可以看到默认会进manjaro的启动界面，可以选择Manjaro和Window Boot Manager.\n双系统安装完成。\n\n1.1 单硬盘单系统如果你对windows深痛恶绝，则在第15步的时候直接erase即可（应该是擦除），但是还是建议你在制作u盘的时候，下载一下windows iso, 拖进u盘。不然哪一天你不想用Linux了，想换回WIN, 很可能换不回去。因为linux下的ventoy制作u盘存在bug.\n2. 代理配置\n\n\n\n\n\n\n\n\n必备步骤，没有代理的话Github， Aur，很多论坛用不了，对于Arch或者说Linux来讲是毁灭性的。建议买个机场。\n2.1 下载并配置clash for windows(cfs)下载clash-for-windows linux, 去web archieve里找最后的版本。\n笔者使用的方案是在手机里下好cfs，然后传到邮箱下载到manjaro内。\n下好了解压，进文件夹\nbash./cfw并设置开机启动，关闭通知（存在kde通知bug），enable IPV6.\nclash verge 和 v2rayA 这两个GUI版本不建议用。Linux下优化的很差。\n2.2 全局代理（应用管理中心，插件下载，桌面壁纸， firefox）配置一下全局代理。主要是为了pamac, 以及各种manjaro自带的下载器，如插件下载。\n\n\nbashkate /etc/environment添加一下，然后保存。如果你使用的是cfw的话，proxy-server:port 替换成127.0.0.1:7890.\ntxthttp_proxy=&quot;http://proxy-server:port/&quot;\nhttps_proxy=&quot;https://proxy-server:port/&quot;\nftp_proxy=&quot;ftp://proxy-server:port/&quot;\nno_proxy=&quot;localhost,127.0.0.1,::1&quot;2.3 终端代理此外，还需要对终端配置代理。不少操作，如pacman, npm, 都得走终端。\nbashkate ~/.bashrcbashkate ~/.zshrc并分别向这两个文件里添加\ntxtexport all_proxy=&quot;socks5://127.0.0.1:7890&quot;保存，然后终端输入, 看一下当前的ip有没有代理上。\nbashcurl cip.cc2.4 系统代理\n照搬即可，为的是解决google等软件的联网问题。\n3. 中文输入法\n直接下Fcitx5就可以。还需要manjaro-asian-input, 选择中文。\n\n然后打开设置，找到输入法，添加拼音。\n点击全局设置，这个就是切换中&#x2F;英输入法。\n\n4. 美化直接看youtube视频吧。ui这玩意各有所爱。推荐YT上搜 make Manjaro kde looks like mac. 成品长这样。这玩意笔记没法写。第一次调的时候看教程，之后滚挂了自己慢慢摸索就行xd.\n\n5. 平滑滚动bashkate ~/.config/kwinrcx11下 笔记本muxless无解。可以试一下 primes selector 让n卡开启 fsync.\n不知道怎么开的话可以用笨办法。先 pamac 安装一个 wine , 然后随便网上下个 exe安装包。用 wine 运行安装包，然后等 安装窗口 出来后就可以关掉安装窗口了。此时会发现上下滚动变得丝滑率。其原理wine在执行 exe安装 的时候会把 fsync 打开。\nwayland下不会出现这个问题问题。\nManjaro 日常使用1. BIOS Update之后，Manjaro EFI Manager界面消失由于win系统下的更新，电脑启动后，可能会弹出bios更新。在更新了Bios之后，很可能Manjaro的grubx64.efi会变非默认priority状态。此时系统会默认进到windows， manjaro不会被引导。有两种解决办法。\n1.1 临时： U盘重新引导使用我们安装Manjaro的u盘，进bios,选择u盘启动。\n然后进入manjaro安装前的那个界面，就是选语言、驱动的那个。\n然后选择detect EFI xxx, 进去后找到manjaro的grubx64.efi那一行。enter后就能进入。\n缺点是每次都得这么走。麻烦\n1.2 grub-install 和 update-grub这两个应该是自带的。没有的话去pamac里面下。\n进入终端，输入su，进root模式\n第一次输入的时候\nbashupdate-grub很大情况下你会在末尾看到这样一段输出：\nbashWarning: GRUB bootloader at /boot/efi/EFI/Manjaro was updated,\nbut it seems like you are not using it by default.\nPlease check your EFI boot priorities!问题得到验证。Manjaro的efi没有被置于最优先。\n接下来输入，重新安装grub\nbashgrub-install --target=x86_64-efi --efi-directory=/boot/efi --bootloader-id=manjaro --recheck然后再update-grub\nbashupdate-grub看到done就可以了。重启。\nbashFound theme: /usr/share/grub/themes/manjaro/theme.txt\nFound linux image: /boot/vmlinuz-6.6-x86_64\nFound initrd image: /boot/amd-ucode.img /boot/initramfs-6.6-x86_64.img\nFound initrd fallback image: /boot/initramfs-6.6-x86_64-fallback.img\nWarning: os-prober will be executed to detect other bootable partitions.\nIts output will be used to detect bootable binaries on them and create new boot entries.\nFound Windows Boot Manager on /dev/nvme0n1p1@/EFI/Microsoft/Boot/bootmgfw.efi\nAdding boot menu entry for UEFI Firmware Settings ...\nRoot filesystem isn&#39;t btrfs\nIf you think an error has occurred, please file a bug report at &quot;https://github.com/Antynea/grub-btrfs&quot;\nFound memtest86+ image: /boot/memtest86+/memtest.bin\n/usr/bin/grub-probe: warning: unknown device type nvme0n1.\nFound memtest86+ EFI image: /boot/memtest86+/memtest.efi\n/usr/bin/grub-probe: warning: unknown device type nvme0n1.\ndone\n2. Hexo从github备份仓库pull下来之后，deasync可能会出错。uninstall然后reinstall就行。\n删掉.deploy_git。 否则可能会push不上去\n3. Manjaro 开发环境配置3.1 Manjaro配置 Java环境3.1.1 JDKhttps://www.oracle.com/java/technologies/downloads/\n下载对应系统的JDK版本。\n打开终端\nbash    ~/Downloads  ls                                                                                  ✔ \n app-tv-release-start-14008.apk                  jdk-21.0.2\n&#39;assignment5-flowchart (1).drawio&#39;               jdk-21_linux-x64_bin.tar.gz\n&#39;assignment5-flowchart (2).drawio&#39;               lutris-GE-Proton8-27-LoL-x86_64\n assignment5-flowchart.drawio                    MacSonoma-kde-main.zip\n assignment5-flowchart.png                       START-installer-v0.11.0.16866.exe\n Clash.for.Windows-0.20.39-x64-linux.tar.gz    \n com.github.vinceliuice.WhiteSur                 wine-lutris-GE-Proton8-27-LoL-x86_64.tar.xz\n    ~/Downloads  mv jdk-21.0.2/ /usr/local                                                           ✔ \nmv: cannot move &#39;jdk-21.0.2/&#39; to &#39;/usr/local/jdk-21.0.2&#39;: Permission denied\n    ~/Downloads  su                                                                                1 ✘ \nPassword: \n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# mv jdk-21\njdk-21.0.2/                  jdk-21_linux-x64_bin.tar.gz  \n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# mv jdk-21\njdk-21.0.2/                  jdk-21_linux-x64_bin.tar.gz  \n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# mv jdk-21.0.2/ /usr/local/\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# kate /etc/profile\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# kate /etc/environment\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# pwd\n/home/anicaa/Downloads\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# cd /usr/local\n[anicaa-rogzephyrusg14ga401iuga401iu local]# ls\nbin  etc  games  include  jdk-21.0.2  lib  man  sbin  share  src\n[anicaa-rogzephyrusg14ga401iuga401iu local]# cd jdk-21.0.2\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# ls\nbin  conf  include  jmods  legal  lib  LICENSE  man  README  release\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# cd bin\n[anicaa-rogzephyrusg14ga401iuga401iu bin]# pwd\n/usr/local/jdk-21.0.2/bin\n[anicaa-rogzephyrusg14ga401iuga401iu bin]# cd ..\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# cd /home/downloads\nbash: cd: /home/downloads: No such file or directory\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# ls\nbin  conf  include  jmods  legal  lib  LICENSE  man  README  release\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# ^C\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# ^C\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# ^C\n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# cd /home/anicaa/Do\nDocuments/ Downloads/ \n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# cd /home/anicaa/Do\nDocuments/ Downloads/ \n[anicaa-rogzephyrusg14ga401iuga401iu jdk-21.0.2]# cd /home/anicaa/Downloads\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# ls\n apache-maven-3.9.6-bin.tar.gz                   com.github.vinceliuice.WhiteSur.tar.xz\n app-tv-release-start-14008.apk                  jdk-21_linux-x64_bin.tar.gz\n&#39;assignment5-flowchart (1).drawio&#39;               lutris-GE-Proton8-27-LoL-x86_64\n&#39;assignment5-flowchart (2).drawio&#39;               MacSonoma-kde-main.zip\n assignment5-flowchart.drawio                    START-installer-v0.11.0.16866.exe\n assignment5-flowchart.png                      &#39;WhiteSur.layout (1).latte&#39;\n Clash.for.Windows-0.20.39-x64-linux.tar.gz      WhiteSur.layout.latte\n CloudGame_netease_setup_pc_x64_1.6.8.0632.exe   wine-lutris-GE-Proton8-27-LoL-x86_64.tar.xz\n com.github.vinceliuice.WhiteSur\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# ls\n apache-maven-3.9.6                              com.github.vinceliuice.WhiteSur\n apache-maven-3.9.6-bin.tar.gz                   com.github.vinceliuice.WhiteSur.tar.xz\n app-tv-release-start-14008.apk                  jdk-21_linux-x64_bin.tar.gz\n&#39;assignment5-flowchart (1).drawio&#39;               lutris-GE-Proton8-27-LoL-x86_64\n&#39;assignment5-flowchart (2).drawio&#39;               MacSonoma-kde-main.zip\n assignment5-flowchart.drawio                    START-installer-v0.11.0.16866.exe\n assignment5-flowchart.png                      &#39;WhiteSur.layout (1).latte&#39;\n Clash.for.Windows-0.20.39-x64-linux.tar.gz      WhiteSur.layout.latte\n CloudGame_netease_setup_pc_x64_1.6.8.0632.exe   wine-lutris-GE-Proton8-27-LoL-x86_64.tar.xz\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# mv apache-maven-3.9.6 /usr/local\n[anicaa-rogzephyrusg14ga401iuga401iu Downloads]# cd /usr/local\n[anicaa-rogzephyrusg14ga401iuga401iu local]# ls\napache-maven-3.9.6  bin  etc  games  include  jdk-21.0.2  lib  man  sbin  share  src\n[anicaa-rogzephyrusg14ga401iuga401iu local]# cd apache-maven-3.9.6\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# ls\nbin  boot  conf  lib  LICENSE  NOTICE  README.txt\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# pwd\n/usr/local/apache-maven-3.9.6\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# source /etc/environments\nbash: /etc/environments: No such file or directory\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# source /etc/environment\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# $JAVA_HOME\nbash: /usr/local/jdk-21.0.2: Is a directory\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# $MAVEN_HOME\nbash: /usr/local/apache-maven-3.9.6: Is a directory\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# echo $JAVA_HOME\n/usr/local/jdk-21.0.2\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# echo $JAVA_HOME/bin\n/usr/local/jdk-21.0.2/bin\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# kate /etc/profile\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# echo $PATH\n/home/anicaa/.local/bin:/usr/local/sbin:/usr/local/bin:/usr/bin:/usr/lib/jvm/default/bin:/usr/bin/site_perl:/usr/bin/vendor_perl:/usr/bin/core_perl\n[anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# source /etc/profile\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# ^C\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# ^C\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# ^C\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# ^C\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# java --version\nopenjdk 21.0.2 2024-01-16\nOpenJDK Runtime Environment (build 21.0.2+13)\nOpenJDK 64-Bit Server VM (build 21.0.2+13, mixed mode, sharing)\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# mvn --version\nApache Maven 3.9.6 (bc0240f3c744dd6b6ec2920b3cd08dcc295161ae)\nMaven home: /usr/local/apache-maven-3.9.6\nJava version: 21.0.2, vendor: N/A, runtime: /usr/lib/jvm/java-21-openjdk\nDefault locale: en_GB, platform encoding: UTF-8\nOS name: &quot;linux&quot;, version: &quot;6.6.16-2-manjaro&quot;, arch: &quot;amd64&quot;, family: &quot;unix&quot;\n[root@anicaa-rogzephyrusg14ga401iuga401iu apache-maven-3.9.6]# \n4. DNS配置在完成了上面代理配置之后，我们在终端输入\nbashping google.com依旧是不行的。因为解析不到。\n所以换成谷歌dns\n配置移步：https://www.anicaaz.com/post/ArchLinux%E4%B8%8BGIT%E7%9A%84%E9%85%8D%E7%BD%AE\n5. Plasma Desktop&#x2F;Panel Widgets DevelopmentIntro and tutorial please see https://develop.kde.org/docs/plasma/widget/setup/\n6. OBS安装后无法启动删掉libva-vdpau-driver\n7. Failed to sync all databasesbashsudo rm /var/lib/pacman/db.lck8. ROG控制中心https://asus-linux.org/\n9. 外服游戏加速器bashcurl -s uudeck.com | sudo bash直接终端输入，回车完会提示Installation succeeded!\n其原理就是用了uu加速器的 Steamdeck 版本(内置插件加速选项)。Steamdeck也是kde桌面环境，所以Arch系kde应该是完全没问题。在系统服务里面能看到uuplugin. \n\n最后手机上下载uu主机加速，账号登录，匹配即可。\n","slug":"Manjaro配置","date":"2024-02-25T01:34:49.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"Kangwei Zhu"},{"id":"434bc80dd156bfbd101b8db7a29c93aa","title":"Cheat Engine for League制作","content":"0. 前言在完结了对 英雄联盟客户端API 的探索之后，我们就可以开始转向 英雄联盟游戏端 的探索了。\n笔者有话说：\n\n\n\n\n\n\n\n\n\n不同于探索 LCU API ， 游戏端的探索 涉及到 逆向、内存、系统编程等主题， 远不止 像探索客户端那样简单， 只用访问接口。一定要耐下心来，慢慢跟着教程走，切莫好高骛远。写这个项目，抑或是说探索整个英雄联盟客户端以及游戏端的初衷，并不是为了 功利性地去制作和出售 这些可能导致游戏失去平衡的工具。更多的是兴趣使然。希望看到这篇教程的读者，也能抱着这个目的，来学习这个项目。\n1. 准备步骤1.1 魔改Cheat Engine\n\n\n\n\n\n\n\n\n截止2024年1月11日，该方法是完全能过外服英雄联盟（AC)，以及国服英雄联盟（ACE)的。只要跟着步骤走，一定不会弹出黑客软件提示。未来拳头会将外服英雄联盟的反作弊升级成kernel-level的vanguard。该方法可用性存疑。\n1.1.2 Lazarus编译器\n\n\n\n\n\n\n\n\nLazarus是一款Pascal的IDE。本质和你们见过的vs-code，vs， idea等等没有任何区别。只不过是编译pascal项目用的。咱们的Cheat Engine（CE）就是用Pascal做的。因为市面上绝大多数网友的反作弊（Anti-Cheat) 都针对CE做了反调试，所以使用官方版的CE，肯定是没法进游戏的（就算进去了，扫内存之后也是卡死）。因此，我们需要从github上下载CE的源码（source code), 然后魔改它，最后重新编译，以绕过检测\nLazarus下载地址: https://sourceforge.net/projects/lazarus/files/Lazarus%20Windows%2032%20bits/Lazarus%202.2.2/\n\n无法访问的话，可以去百度网盘下载整套资料包\n1.1.2 Cheat Engine下载\n1.1.3 修改驱动名称\n\n\n\n\n\n\n\n\n很多AC都将dbk32.sys， dbk64.sys纳入黑名单。因此，你需要修改替换他们的名称。\n\n可以用记事本打开，进去后，找到这三个\n\n将这三个值改成你要的值。\n\n改完之后，ctrl + s保存退出。\n1.1.4 修改并编译Cheat Engine找到该文件，用Lazarus打开。\n\n进去之后应该会看到这样一个界面。\n\n如果这个Object Inspector是空的话，按ctrl + shift + f12 搜索MainForm。就能加载出来。\n\n忽略Caption上面的三个箭头。只用修改Caption的值，也就是Cheat Engine. 把他改成你想要的。\n然后点击Project-&gt;Project Options.\n\n\n\n\n64位里面，OVA也要。所以一共有三个！\n箭头指到的都要替换名字。\n1.1.5 完成编译\n\n只用选这三个。然后坐等编译完成。箭头指着的就是编译进度。\n\n完事了之后会跳这个消息。也就标志着编译已经完成！\n\n1.1.6 对成品进行魔改\n\n\n\n\n\n\n\n\n改完了之后，应该可以在bin下面看到这三个文件。随便挑一个打开，可以看到标题还是Cheat Engine。这就比较操蛋了。我们还得接着改。\n\n这时候我们就需要一个叫HxD的软件。下载链接： HxDSetup.zip \n没法下载的话，同样去网盘资源包里安装\n安装好了后，把你编译好的CE，拖到 HxD里面去。\n\n然后搜索并替换Cheat Engine字段。注意选择区分大小写、从头，然后点击全部替换S\n\n\n改完后保存退出，在重新打开你编译好的CE。应该就能看到这些。当然这里是我的值，你应该和我不一样。\n\n然后，把你修改过一次的exe, 在拖进HxD。搜索并替换“cheat engine”，“cheatengine”， “CheatEngine”这三个字段。\n然后，再对文本编码：”中的“Unicode（UTF-16 小端）”选项，对四个字段（前面的Cheat Engine加上这三个），再搜索并替换。\n以上这7个操作，同样注意选择区分大小写、从头，然后点击全部替换。\n:warning: 原来字段带空格，你替换的字段也要带空格。你替换的字段长度必须等于原来的字段长度。如果出现替换完没法打开，去Lazarus中选择clean and build重新来。\n1.1.7 VMProtect可以在资料包里找到。安装后，同样是把修改过的exe拖进去。\n\n点击选项，修改成变异+虚拟\n\n然后点击左栏里的选项。修改成和图片的一样。输出文件不要动。\n\n改完后，点击编译。\n\n1.1.8 String Lua Script（可选）\n打开Lua Engine，复制黏贴以下代码\nluafunction renameComponents(c)\n  local i\n  if c.Component then\n    for i=0,c.ComponentCount-1 do\n      renameComponents(c.Component[i])\n    end\n  end\n \n  if c.Caption then\n    c.Caption=&#39;WTF&#39;\n  end\nend\n \n \nfor i=0,getFormCount()-1 do\n    local form = getForm(i)\n    for j=0,form.ControlCount-1 do\n      renameComponents(form)\n    end\n \n    form.Caption=&#39;Bla&#39;\nend\n \nregisterFormAddNotification(function(f)\n  f.registerCreateCallback(function(frm)\n    renameComponents(f)\n  end)\nend)\n这样所有字符串都会被替换成‘WTF’. 不过似乎用这段脚本的人很多，建议把这个’WTF‘改成你想要的，避免被检测到。如果觉得全部替换后，整个CE都不会用了，关掉CE重启即可。\n1.1.9 下载VS2019和WDK。https://docs.microsoft.com/de-de/vis.../release-notes\n选择Community 2019 Edition就可以了。\n下载完成后点击。\n\n\n\n选中这六个。\n- MSVC v142 - VS 2019 C++ x64&#x2F;x86 Spectre-mitigated libs (latest)- MSVC v142 - VS 2019 C++ x64&#x2F;x86 build tools (latest)- C++ ATL for latest v142 build tools (x86 &amp; x64)- C++ ATL for latest v142 build tools with Spectre Mitigations (x86 &amp; x64)- C++ MFC for latest v142 build tools with Spectre Mitigations (x86 &amp; x64)\n然后点击安装就可以。安装完后，下载\nhttps://developer.microsoft.com/de-de/windows/downloads/sdk-archive/\n\n下完后打开，一路点点点就好。\n之后下载这两个。\nwdk: https://learn.microsoft.com/de-de/windows-hardware/drivers/other-wdk-downloads\n\nsdk: https://developer.microsoft.com/en-us/windows/downloads/windows-sdk/\n\n资料包里也有。下载慢，打不开的话直接在资料包里下。\n :warning:  安装完wdk必须看到这三个。否则后面没法搞。如果没出现这个。一定是你sdk&#x2F;wdk出问题了。控制面板里删掉重新装。\n\n\n\n下完之后打开这个。\n双击打开。\n\n\nctrl+h替换dbk64. 替换的值，就是你在这个文件里替换的值。\n然后点击全部替换。替换完成之后，查找ManufacturerName。替换成你的名字。\n接着替换下面信息。\n\n\n\n\n创建完成后，点击应用。\n\n然后点击生成-&gt;生成解决方案。\n如果出现WDK报错，重新进到DBKKernel。修改Windows SDK版本\n\n编译成功后，回到bin目录下的dbkkernal，应该能看到驱动名称已经被改成你自定义的名称了。\n\n1.1.10  禁用Driver Signature Enforcement（DSE)放在资料包里了。直接点击exe。输入yes就就可以。一般都是开机先打开exe，再打开，再开游戏。\nupdate: 使用dse-patcher。注意，在有kernel-level反作弊的游戏启动前，得先enable-dse。否则游戏不会启动。在启动后，再disable dse。\n1.1.11 Module Lua Script同样放在CE的Lua Engine里执行一下。主要是解决国服英雄联盟把所有的module名字全部隐藏的情况（如下）。当然其他游戏出现这种情况也是用这段代码。\ntxtsymbols = createSymbolList();\nsymbols.register();\n \nfunction onOpenProcess(pid)\n    symbols.unregister();\n    symbols = createSymbolList();\n    symbols.register();\n \n    reinitializeSymbolhandler();\n \n    if (pid == 4) then\n        return;\n    end\n \n    local proc = dbk_getPEProcess(pid);\n    --printf(&quot;proc: %08X&quot;, proc);\n \n    local peb = readQword(proc + 0x550);\n    --printf(&quot;peb: %08X&quot;, peb);\n \n    local ldr = readQword(peb + 0x18);\n    --printf(&quot;ldr: %08X&quot;, ldr);\n \n    local index = readQword(ldr + 0x10);\n    --printf(&quot;index: %08X\\n&quot;, index);\n \n    while (index ~= ldr + 0x10) do\n          local mod = readQword(index);\n          --printf(&quot;mod: %08X&quot;, mod);\n \n          local name = readString(readQword(mod + 0x58 + 0x8), readSmallInteger(mod + 0x58), true);\n          --printf(&quot;name: %s&quot;, name);\n \n          local base = readQword(mod + 0x30);\n          --printf(&quot;base: %08X&quot;, base);\n \n          local size = readInteger(mod + 0x40);\n          --printf(&quot;size: %04X\\n&quot;, size);\n \n          symbols.addModule(name, &quot;&quot;, base, size, true);\n \n          index = readQword(mod);\n    end\n \n    local name = readString(proc + 0x5A8, 15);\n    --print(&quot;name:&quot;, name);\n \n    local base = readQword(proc + 0x520);\n    --printf(&quot;base: %08X&quot;, base);\n \n    local size = readQword(proc + 0x498);\n    --printf(&quot;size: %04X&quot;, size);\n \n    symbols.addModule(name, &quot;&quot;, base, size);\n \n    reinitializeSymbolhandler();\n \n    --print(&quot;finished!&quot;);\nend1.1.12 最后一步：隐藏OutputDebugString()从资料暴力找到图片中的dll。\n第一步Done！\nps:\n一些ce设置：\n\n\n\n1.2 测试成果 - 无限视距首先启动CE，打开英雄联盟，进入游戏。\n首先我们通过鼠标滚轮，将视距调整为默认。将你的ce搜索选项，设置为箭头所指的值。\n\n然后，搜这个数字：2250. \n\n然后，进入游戏，通过滚轮将视距调为最小. 调整围城后\n调整完成后，回到CE。可以观察到，有两个原本为2250的值，变成1000了。\n这就是我们要调整的视距。\n选中这两个值，放入下面。然后点击1000，将其修改至5000。回到游戏&#x2F;\n瞬间大了很多。但是还有一个问题。每次你移动滚轮之后，视距都会重新变成2250. \n这是因为英雄联盟设定了视距的最大值。很明显，刚才我们找到的那两个值，只是当前视距的值。我们还需要找到最大视距的那个2250，并修改成我们想要的值，这样子才不会被重置。\n首先，全选上面的值，将其移到address list中。\n这些浮点值肯定是不要的。因为最大值是2250整数。我们直接把他们移除。\n那两个当前值肯定也是不要的。删掉。\n接下来，我们采用二分的方法，将剩下来的这些2250，分成两组，每次修改一组，直接改成5000，看能不能解锁最大视距。\n\n\n也是很给力，第一次改就对了。\n那么说明最大值肯定在第一组5000中。不断缩小范围，修改成2250，看有没有影响。就肯定能找到最大值。这里就不再一一记录了。记住，找到最大值后，一定要将被修改的值，重新改回2250.\n2. 脚本制作2.1 JavaFX2.2 编写第一个游戏内部绘制（透明）javapackage com.anicaaz.leaguewaregcfx.examples.ui;\n\nimport javafx.application.Application;\nimport javafx.geometry.Insets;\nimport javafx.geometry.Pos;\nimport javafx.scene.Scene;\nimport javafx.scene.control.Label;\nimport javafx.scene.layout.StackPane;\nimport javafx.scene.paint.Color;\nimport javafx.stage.Stage;\nimport javafx.stage.StageStyle;\n\n/**\n * 第一个使用JavaFX创建的Overlay\n * 主要干了以下几点：\n *      1. 全透明： 将stage, Scene, Pane全部设为透明。\n *      2. 通过setAlignment将文本设为右上方。\n *      3. 根据显示情况，通过setMargin调整位置。\n *\n *  todo:\n *      1. 根据设备屏幕大小，设置元素的位置。\n *\n * @author anicaazhu\n */\npublic class FirstJavaFXOverlay extends Application &#123;\n\n    @Override\n    public void start(Stage primaryStage) &#123;\n        // 创建一个标签用于显示文本\n        Label label = new Label(&quot;Test&quot;);\n        label.setTextFill(Color.BLACK); // 设置文本颜色\n        label.setStyle(&quot;-fx-font-size: 30px&quot;);\n        \n        // 创建一个栈面板作为根节点\n        StackPane root = new StackPane();\n        root.getChildren().add(label);\n        root.setStyle(&quot;-fx-background-color: transparent;&quot;); // 设置根节点背景透明\n        StackPane.setAlignment(label, Pos.TOP_RIGHT);\n        StackPane.setMargin(label,new Insets(150,300,0,0));\n\n        // 创建场景，设置背景透明\n        Scene scene = new Scene(root, 1920, 1080);\n        scene.setFill(Color.TRANSPARENT); // 设置场景背景透明\n\n        // 设置舞台样式为TRANSPARENT\n        primaryStage.initStyle(StageStyle.TRANSPARENT);\n        primaryStage.setScene(scene);\n        primaryStage.show();\n        primaryStage.setAlwaysOnTop(true);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        launch(args);\n    &#125;\n&#125;2.3 编写无限视距的具体实现2.3.1 Tasklist在PowerShell中输入\npowershelltasklist来查看所有进程信息。\n如果你这时候已经启动英雄联盟游戏的话，你应该会看到这个。\n\n这个就是英雄联盟游戏进程。我们需要通过Java&#x2F;C#&#x2F;C++的内存库，通过进程名，来修改内存中的数据。\n致谢\n\n\n\n\n\n\n\n\n没有以下作者的资源，本教程（或是笔记）绝无可能完成。\n\nhttps://www.unknowncheats.me/forum/anti-cheat-bypass/504191-undetected-cheat-engine-driver-2022-bypass-anticheats-eac.html\n\nhttps://www.unknowncheats.me/forum/league-of-legends/562594-undetected-cheat-engine-debugger-league-legends-2023-crashes.html#post3631960\n\nhttps://stackoverflow.com/questions/18849609/how-to-manipulate-memory-from-java-with-jna-on-windows\n\n\n","slug":"League-of-Legends-Game-Client探索","date":"2024-01-14T13:19:00.000Z","categories_index":"软件测试","tags_index":"","author_index":"Kangwei Zhu"},{"id":"d97ea25e482095e1a957035cc4432c91","title":"Jira","content":"1. 软件缺陷例子:计算器 屏幕不能显示结果\n\n​\t\n缺陷的基本内容\n\n缺陷标题\n预置条件\n重现步骤\n期望结果\n实际结果\n\n缺陷的状态\n\n新建\n打开\n修复\n关闭\n\n缺陷的严重程度\n\n致命 (无法打开)\n严重 (主要功能缺失)\n一般 (功能异常)\n建议 (可改可不改)\n\n缺陷的优先级\n1.低\n2.中\n3.高\n\n\n\n\n\n\n\n\n\n测试人员只能对优先级提出建议, 真正决定其优先级的是项目经理&#x2F;领导\n软件缺陷的类型\n\n代码错误\n设计缺陷\n性能问题\n安全相关\n\n软件缺陷的跟踪流程\n\n提交 (测试)\n\n确认 (开发)\n\n打开 (缺陷状态)\n\n修复 (开发)\n\n回归 (测试)\n\n关闭 (缺陷状态)\n\n\n2. Jira\n\n\n\n\n\n\n\n\n提高协作效率\n2.1 Jira的介绍\n\n\n\n\n\n\n\n\n由Atlassian开发的一款软件问题跟踪,管理工具\n\n支持多语言\n支持多平台运行\n配置灵活, 功能强大\n\n2.2 Jira的使用者\n企业管理层\n项目经理\n软件测试人员\n开发人员 \n运维&#x2F;设计\n\n2.3 Jira中的问题(Issue)Issue包括\n\n缺陷\n新功能\n新人物\n改进\n\n2.4 Jira中的工作流To do -&gt; In progress -&gt; in review -&gt; done\n(待办)-&gt; 进行中-&gt;评审中-&gt;进行结束\n工作流: 问题的不同阶段\n也可以自己定义工作流.\n2.5 Jira的使用\n测试提交\n\n开发确认\n\n开发修复\n\n测试回归\n\n\n2.6 创建缺陷\n\n","slug":"Jira","date":"2023-11-10T04:56:54.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"06504b49e72fd84dc1ebbbac6ca8b7dd","title":"Leetcode刷题日记","content":"\n\n\n\n\n\n\n\n\n这几天在回顾前面刷的前150道LC, 发现除了easy以外的,还有少数medium, 其他的要么不是bug free要么就是完全没头绪. 从今天开始, 每天保持至少1题LC + 解析, 方便日后重新捡起.\n1&#x2F;8&#x2F;202422. Generate Parentheses\n\n\n\n\n\n\n\n\n回溯的题， 题意非常简单。给定 n组 括号， 输出所有 well-formed 括号的组合。首先需要注意的就是well-formed的定义。 well-formed指的是 左括号在前，右括号在后” 的组合方式，给了多少组括号，则这些括号都需要满足这种组合方式。\n答案以List形式输出。\n下面是两个简单例子。\ntxtn = 1, output = [&quot;()&quot;]txtn = 2, output = [&quot;(())&quot;, &quot;()()&quot;]第一个例子其实不能看出什么规律，我们看下第二个例子的图解。这是第一种情况，以左括号)开始，有以上三种情况。\n第二种情况，以右括号)开始，两种情况。\n从这两张图，我们已经足够推出规律了：    1. 首先，永远只有两种开始情况： 左括号开始和右括号开始。    2. 一旦路径上的 右括号数量 比 左括号数量大， 哪怕就多一个，其实这条路径就没有走的意义了，必然不可能是 well-formed.    3. 在第二条的前提下，如果能够走到 左括号和右括号用尽的情况，就是我们想要的一个答案了。    4. 根据第二条，我们可以看出， 左括号的优先级最大， 我们尽可能地先用完左括号，然后去看右括号号的情况。    5. 用尽左括号的时候，先补全右括号，然后返回到 最早使用过左括号的那一层， 选择用右括号开始，往下走，尝试用尽左括号。遇到走不通的，就回到最早使用过左括号的那一层，换右括号。    6. 不善表达。如果看到这里还是比较迷糊的话，可以跳过代码，先看看对我对回溯的理解。这样以后做到类似理念的题目，也能联想到回溯。\njavaclass Solution &#123;\n    public List&lt;String&gt; generateParenthesis(int n) &#123;\n        List&lt;String&gt; res = new ArrayList&lt;&gt;();\n        backtracking(0, 0, &quot;&quot;, n, res);\n        return res;\n    &#125;\n    \n    public void backtracking(int left, int right, String str, int number, List&lt;String&gt; res) &#123;\n        if (right &gt; left) &#123;\n            return;\n        &#125;\n\n        if (right == number &amp;&amp; left == number) &#123;\n            res.add(str);\n            return;\n        &#125;\n\n        //  加左括号\n        if (left &lt; number) &#123;\n            backtracking(left + 1, right, str + &quot;(&quot;, number, res);\n        &#125;\n\n        // 加右括号\n        if (right &lt; left) &#123;\n            backtracking(left, right + 1, str + &quot;)&quot;, number, res);\n        &#125;\n    &#125;\n&#125;\n\n\n\n\n\n\n\n\n讲一下我对回溯的理解：回溯就像是，当你走到了一个交叉路口，需要选择走哪一边的时候。无论你选择走哪一边，都会经历一系列事情，可能在这些事情里，你还会遇到更多的交叉路口，做出更多的决策。不管是你最后通关，还是失败，你都会决定回到先前的路口，走另外一边，尝试另一种可能。对于每个路口，都是如此。这就是回溯。\n\n2&#x2F;13&#x2F;2024\n\n\n\n\n\n\n\n\n正月初四了，原来已经一个月没有碰题目了，今天也是磨蹭着补了4道题。\n每日一题：2108. Find First Palindromic String in the Arrayjavaclass Solution &#123;\n    public String firstPalindrome(String[] words) &#123;\n        for (int i = 0; i &lt; words.length; i++) &#123;\n            if (isPalindrome(words[i])) &#123;\n                return words[i];\n            &#125;\n        &#125;\n        return &quot;&quot;;\n    &#125;\n\n    public boolean isPalindrome(String word) &#123;\n        char[] ch = word.toCharArray();\n        int left = 0;\n        int right = ch.length - 1;\n        boolean res = true;\n        while (left &lt; right) &#123;\n            if (ch[left] == ch[right]) &#123;\n                left++;\n                right--;\n            &#125; else &#123;\n                res = false;\n                break;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;15. 3Sumjavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; threeSum(int[] nums) &#123;\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        Arrays.sort(nums);\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            if (i &gt; 0 &amp;&amp; nums[i - 1] == nums[i]) &#123;\n                continue;\n            &#125;\n\n            int left = i + 1;\n            int right = nums.length - 1;\n\n            while (left &lt; right) &#123;\n                int sum = nums[i] + nums[left] + nums[right];\n                if (sum &gt; 0) &#123;\n                    right--;\n                &#125; else if (sum &lt; 0) &#123;\n                    left++;\n                &#125; else &#123;\n                    res.add(Arrays.asList(nums[i], nums[left], nums[right]));\n\n                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;\n                        left++;\n                    &#125;\n\n                    while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;\n                        right--;\n                    &#125;\n\n                    left++;\n                    right--;\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;16. 3Sum Closestjavaclass Solution &#123;\n    public int threeSumClosest(int[] nums, int target) &#123;\n        Arrays.sort(nums);\n        int closestSum = nums[0] + nums[1] + nums[2];\n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            int left = i + 1;\n            int right = nums.length - 1;\n            while (left &lt; right) &#123;\n                int sum = nums[i] + nums[left] + nums[right];\n                if (Math.abs(target - sum) &lt; Math.abs(target - closestSum)) &#123;\n                    closestSum = sum;\n                &#125;   \n                if (sum &gt; target) &#123;\n                    right--;\n                &#125; else &#123;\n                    left++;\n                &#125;\n            &#125;\n        &#125;\n        return closestSum;\n    &#125;\n&#125;18. 4Sumjavaclass Solution &#123;\n    public List&lt;List&lt;Integer&gt;&gt; fourSum(int[] nums, int target) &#123;\n        List&lt;List&lt;Integer&gt;&gt; res = new ArrayList&lt;&gt;();\n        Arrays.sort(nums);\n    \n        for (int i = 0; i &lt; nums.length; i++) &#123;\n            if (i &gt; 0 &amp;&amp; nums[i] == nums[i - 1]) &#123;\n                continue;\n            &#125;\n            for (int j = i + 1; j &lt; nums.length; j++) &#123;\n                if (j &gt; i + 1 &amp;&amp; nums[j] == nums[j - 1]) &#123;\n                    continue;\n                &#125;\n                int right = nums.length - 1;\n                int left = j + 1;\n                while (left &lt; right) &#123;\n                    long sum = (long)nums[i] + nums[j] + nums[left] + nums[right]; // leetcode用例存在数据之和超过int最大值。\n                    if (sum == target) &#123;\n                        res.add(Arrays.asList(nums[i], nums[j], nums[left], nums[right]));\n                        while (left &lt; right &amp;&amp; nums[left] == nums[left + 1]) &#123;\n                            left++;\n                        &#125;\n                        while (left &lt; right &amp;&amp; nums[right] == nums[right - 1]) &#123;\n                            right--;\n                        &#125;\n                        right--;\n                        left++;\n                    &#125; else if (sum &lt; target) &#123;\n                        left++;\n                    &#125; else &#123;\n                        right--;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;这三题可以一块看。15题是这种类型的模板。题目都是给定一组 乱序int数组 和一个 target值， 然后围绕 指定数量的，数组下标不同的，元素之和 与 target之间的关系来展开题目。 \n对于这种题目，模板非常简单，往往以下几步就可以解决。\n\n数组排序\n第一层循环，锁死一个数，对这个数进行去重。以3sum为例， 直接锁死下标0的元素， 首先对其进行去重，比如[-1, -1, 0, 1, 2] , 我们不想看到[-1,0,1]这个结果, 在结果集中出现两次。\n锁死一个下标的数之后，左指针指向这个数字右侧的一个数，右指针指向数组末尾。\n再套一层循环，判断当前这个三个下标（锁死的下标，左指针，右指针）的数之和与target关系。 三种情况，分别讨论，同时做左指针和右指针所指向的数字的去重。\n\n有了这个模板之后，其实无论是3sum， 4sum， 5sum，都是一样的做法。不过这个规律其实从2sum开始就存在了，但是2sum没有3sum那几步额外操作。\n2&#x2F;14&#x2F;2024每日一题：2149. Rearrange Array Elements by Signjavaclass Solution &#123;\n    public int[] rearrangeArray(int[] nums) &#123;\n        int posI = 0;\n        int negI = 1;\n        int[] res = new int[nums.length];\n        for (int num : nums) &#123;\n            if (num &gt; 0) &#123;\n                res[posI] = num;\n                posI += 2;\n            &#125; else &#123;\n                res[negI] = num;\n                negI += 2;\n            &#125;\n        &#125;\n        return res;\n    &#125;\n&#125;\n\n\n","slug":"leetcode刷题日记","date":"2023-11-09T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"546f17bbf71609ffe80d0b2675ac3c15","title":"键盘上的符号对应的英文名称","content":"\n\n\n\n\n\n\n\n\n一次惨痛的交流经历: 写算法时候得边写边讲解, 结果不知道键盘上的诸多符号怎么用英文表达. 遂搜了一下常见的符号用英文的表达方式.\ntxt! 叹号 exclamation mark/bang\n? 问号 question mark\n, 逗号 comma\n. 点号 dot/period/point\n: 冒号 colon\n; 分号 semicolon\n” 双引号 quotation marks/double quote\n‘ 单引号/撇号 apostrophe/single quote\n` 重音号 backquote/grave accent\n* 星号 asterisk/star\n+ 加号 plus sign\n- 减号/横线 hyphen/dash/minus sign/\n= 等号 equal sign\n/ 斜线 slash\n\\ 反斜线 backslash/escape\n| 竖线 bar/pipe/vertical bar\n_ 下划线 underline/underscore\n$ 美元符号 dollar sign\n@ at at sign\n# 井号 crosshatch/sharp/hash\n% 百分号 percent sign/mod\n&amp; and/和/兼 and/ampersand\n^ 折音号 circumflex/caret\n~ 波浪号 tilde\n&#123;&#125; （左右）花括号/大括号 (left/right|open/close) braces\n[] （左右）方括号/中括号 (left/right|open/close) brackets\n() （左右）圆括号/小括号 (left/right|open/close) parentheses\n&lt;&gt; 尖括号 angle brackets\n&lt; 大于号 less than\n&gt; 小于号 greater than来源:https://www.douban.com/group/topic/12410327/?_i=96771150h8Lclu键盘上所有特殊符号的英文读法 \n","slug":"键盘上的符号对应的英文名称","date":"2023-11-09T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"7571cb194f7c4b5f1528b0f44328eda0","title":"App手工测试要点","content":"1. App 手工测试基础知识1.1 App架构\n基本和Web的后端服务器是相同的\n\n表示层 应用层 数据库\n\n\n前后端也使用HTTP协议进行交互\n\nApp中, 前后端传值以json为主. 而Web端既可以是json, 也可以是文本\n\nKV\n因为App的前端是写死(hardcoded)在App中的\n\n\n\n\nAPP是C&#x2F;S结构,而Web浏览器是B&#x2F;S结构\n\n新版本要升级,但是web不用\n\n\n\n1.2 项目环境\n开发环境\n开发人员进行开发时调试运行的环境\n\n\n测试环境\n提供给测试人员使用,用于测试人员进行测试,回归缺陷\n\n\n预发布环境\n连接到生产环境的数据库.使用生产环境的数据来进行测试\n和测试环境的数据相比,数据更复杂.\n涉及到写入数据库的业务操作时,只能用自己构造的数据.\n\n\n生产环境\n正式提供对外服务的环境,产品的实际用户使用的环境\n\n\n\n\n\n\n\n\n\n\n\n\n灰度发布: 先对部分机器投放版本更新, 如果反馈没问题, 再将剩余一起投放更新. 如果新功能存在问题,则只需要回滚投放更新的那几台.\n投放策略: 比如选择尾号为0的用户进行投放.\n注意点:\n\n灰度机器不能太多\n灰度时间一般在一周到一个约\n灰度发布时不能影响用户的使用.\n出现问题后,需要到测试环境里来复现问题. 如果问题非常严重, 则需要立马回滚\n\n1.3 APP发布APP开发完成后,开发人员会将其打包, 由测试人员安装测试\n\n安卓: APK测试包\nIOS: IPA测试包\n\n应用线上发布平台:安卓: google store\nIOS: App Store\n1.4 敏捷开发\n敏捷开发以用户的需求进化为核心,采用迭代,循序渐进的方法进行软件开发\n项目被分为若个子项目, 各个自项目的成果都经过测试, 具备可视,可集成,可运行使用的特征.\n\n1.4.1 瀑布模型\n\n\n\n\n\n\n\n\n线性地进行项目\n\n定义阶段\n可行性\n需求分析\n\n\n开发阶段\n设计\n编码\n测试\n\n\n维护阶段\n运行维护\n\n\n\n缺点: 开发周期长,迭代速度慢\n1.4.2 为什么采用敏捷开发\n互联网行业发展速度快,需求不断变化,产品更新迭代的频率高\n\n试错快\n\n\ntxt代表性的敏捷开发模型: Scrum1.4.3 Scrum\n\n\n\n\n\n\n\n\n一个增量的, 迭代的开发过程. 在这个框架中,整个开发周期包括若干个小的迭代周期. 每个小的迭代周期被称为一个Sprint. 每个Sprint周期建议为2~4周. 在Scrum中,将产品Backlog(任务待办列表),按商业价值进行排序. 挑选出最有价值的需求进行开发, 开发完成后将产品推进市场,进行下一个版本的迭代.\n三种角色\n\nProduct Owner\n\n定义产品功能, 决定发布内容和日期, 根据市场的变化对需要开发的功能排列优先顺序\n\n\nScrum Manager\n\n确保团队不受外界影响\n确保团队生产率\n\n\nDev Team\n\n程序员\\测试员\\用户体验设计师\n主要职责是实现用户需求\n\n\n\n开发流程:\n收集需求, 生成产品功能列表\n计划会: 确定优先级高的功能: 市场需求, 存在缺陷\n进行迭代(小瀑布)\n2. App测试流程\n参与需求评审\n制定测试计划: 项目的功能模块, 负责人, 环境,\n设计编写测试用例: 根据需求编写用例, 评审用例, 紧张的话,就写测试点就行了.\n执行用例,跟踪缺陷 : JIRA\n版本测试报告: 测试的模块,用例数, 发现的bug,遗留的bug\n\n2.1 测试之前需要了解什么\n项目的作用\n了解项目的目标用户和角色\n了解项目的功能\n了解项目的技术架构\n\n2.2 APP测试要点对于APP项目的测试,一般是进行系统测试\n而系统测试主要包含:\n\n功能测试(重点)\n\n兼容性(不同系统, 不同厂商的手机)\n\n安装\\卸载\\升级测试(因为是C\\S 结构)\n\n交叉事件测试(被其他事件被打断了)\n\nPUSH测试(弹出某个消息提示后)\n\n性能测试(CPU\\内存\\流量\\电量\\流畅度\\启动速度)\n\n用户体验测试\n\n稳定性测试 (运行时常,会不会崩)\n\n\n显式需求\n根据软件说明,设计文档,或用户需求验证App的各个功能的实现\n隐式需求\n被功能影响到的相关业务\n2.3 功能测试实践\n","slug":"app","date":"2023-11-08T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"11afe62c1a1afae5fc60d18c86409058","title":"Operting System Design","content":"1. 为什么要学习OSD？\n\n\n\n\n\n\n\n\nOS forms the foundation of modern computing\n\nAbstractions: Modern Software 是如何使用 Hardware的？\n\nResource Management： 如何去做 resource isolation？\n\n如何在兼顾实现以上两点的同时，确保 High Performace ?\n\n\n在这门课上，主要通过两种方式来学习OS\n\n\nConceptual Learning\n\n\n\nIntensive Programming\n\n\n\n在笔记的书写中，很多时候并不能很好、贴切的翻译一些英文句子和词汇，所以就直接使用了来自课件、书上的原话。\n2. OS 导论OS, 是一个抽象（abstract）和 管理（manage）硬件资源的 软件从高到低排序： 用户 -&gt; 应用程序 -&gt; 操作系统 -&gt; 硬件\n本章将是这门课内容的导论。section 2以后的章节将对对于各个主题，进行更深层次的讨论和总结。\n2.1 硬件OS管理的硬件主要有\n\nmemory： 基本实体都是DRAM,  对应OS中的Memory，使用malloc()作为memory controller, 来分配内存\nDisk：对应OS中的File System, 通过SATA传输，使用read()&#x2F;write() 进行控制\nNework Adapter: 对应OS中的网络模块， 使用send()&#x2F;recv() 进行传输\n\n2.2 OS提供了什么？\nSoftware library (abstraction) between applications and hardware to make the hardware easier to use\n\nSimple, uniform view of diverse hardware devices\n\n\nMechanisms and policies for resource management, to provision and isolate hardware across many applications\n\nEffective multi-tenant（多租户） and multi-application systems\n\n\n\n2.3 Abstrction2.3.1 现代操作系统通常为哪些资源提供哪些抽象?\n\n\n\n\n\n\n\n\nCPU：进程&#x2F;线程内存：地址空间存储：文件\n2.3.2 操作系统提供抽象的好处？\n\n\n\n\n\n\n\n\n允许应用程序重用公共资源让不同的设备看起来相同 （内存、主板、硬盘）提供更高级别或更有用的功能\n2.3.3 挑战\nWhat are the correct abstractions?\nHow much of the hardware capabilities should be exposed?\n\n2.4 System Calls\n系统调用允许用户告诉操作系统在硬件上执行什么操作\n操作系统提供标准软件接口 （API）\n典型的操作系统会导出几百个系统调用\n运行程序、访问内存、访问硬件设备……\n\n2.5 Resource Management\n\n\n\n\n\n\n\n\nWant fair and efficient use of hardware across applications\n2.5.1 Advantages of OS providing resource management:\nProtect applications from one another\nProvide efficient access to resources (cost, time, energy)\nProvide fair access to resources\n\n2.5.2 Challenges\nWhat are the correct mechanisms?\nWhat are the correct policies?\n\n2.6 Virtualization\n\n\n\n\n\n\n\n\nMake each application believe it has each hardware resource to itself这门课主要关注：CPU和Memory\n2.6.1 Virtualizing CPU\n系统有大量的虚拟CPU： 将一个物理CPU转换为实际上无穷多数量的CPU。允许很多程序同时执行\n可以理解成，当我们在命令行同时执行多个c文件的时候，这时候就可以看成是多个程序同时执行，并实际上使用同一个cpu，但是这些c文件，他们认为自己独占cpu。\n\n2.6.2 Virtualizing Memory\n物理内存其实是一个byte数组\n一个程序将自身所有的数据结构存放在内存中\n读取内存 （load）: \n指定一个能够访问数据的地址\n\n\n写入内存 （store）：\n指定要写入特定地址的数据\n\n\n\n虚拟化内存涉及到的一些Mechanism：\n\nVirtual-to-Physical Memory Mapping\nPage-Fault\n\nDemo1： 用c分配内存\nc#include &lt;stdio.h&gt;\n\nint main(int argc, char *argv[1]) &#123;\n    int a = 0;\n    printf(&quot;%d\\n&quot;, a);//0\n    //aa指针指向a的地址\n    int *aa = &amp;a; \n    //加了*是指针，对应一个数据的地址。那么指针加上指针，就是再次得到值。\n    *aa += 1;\n    printf(&quot;%x\\n&quot;, aa);//a16738d4\n    printf(&quot;%d\\n&quot;, a);//1\n\n    //创建p指针，分配内存。\n    int *p = malloc(sizeof(int));\n    //复制给该片区域\n    *p = 100;\n    printf(&quot;address of p: %x\\n&quot;, p); //fbf156b0\n    printf(&quot;value stored in p: %d\\n&quot;, *p);//100\n    printf(&quot;address of p: %x\\n&quot;, &amp;(*p));//fbf156b0\n&#125;每个进程都有自己的私有虚拟内存空间（private virtual memory space），OS则会映射这些address space到物理内存中\n\n对一个正在运行的程序的内存引用，不会影响到其他程序的address space。\n物理内存是一个由OS管理的共享资源\n\n2.7 Concurrency\n\n\n\n\n\n\n\n\nConcurrency（并发）： Events are occurring simultaneously and may interact with one anotherOS必须能够处理并发事件\n比较简单的处理方式： 直接隔离他们，阻止他们交互，从而达到Hide Concurrency的效果。但是，这样子指标不治本。因为很多时候有些任务，就是需要进程间交互才能执行的。这时候，才是真正想办法来处理了。常见做法有：\n\n为进程提供抽象（锁(lock)、信号（semaphores）、条件变量(condition variables)、共享内存(shared memory)、关键部分(critical sections)）\n如果用了锁，则需要确保进程不会死锁\n让交互线程(interaction threads)必须协调对共享数据(shared data)的访问\n\n多线程Demo：\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;pthread.h&gt;\n\nvolatile int counter = 0;\nint loop;\nchar *name;\n\nvoid *worker() &#123;\n    for (int i = 0; i &lt; loop; i++) &#123;\n        counter++;\n    &#125;\n&#125;\n\nint main(int argc, char *argv[]) &#123;\n    loop = atoi(argv[1]);\n    pthread_t p1, p2;\n    printf(&quot;initial value: %d\\n&quot;, counter);\n    pthread_create(&amp;p1, NULL, worker, NULL);\n    pthread_create(&amp;p2, NULL, worker, NULL);\n    pthread_join(p1, NULL);\n    pthread_join(p2, NULL);\n    printf(&quot;Final value: %d\\n&quot;, counter); // 20.\n&#125;可以试着执行之下上面代码。试着改变参数大小。可以发现，如果参数比较小（100~1000），那么最终结果就是参数值*2. 但是，当参数变大后，结果就不对了。\nshell./mte 10\ninitial value: 0\nFinal value: 20\n\n./mte 1000\ninitial value: 0\nFinal value: 2000\n\n./mte 10000\ninitial value: 0\nFinal value: 14692\n\n./mte 1000000\ninitial value: 0\nFinal value: 1007083这是因为并发的情况并没有处理好。p1和p2这两个线程同时执行，并且同时对一个counter进行增加操作。数字小的时候，p1或p2执行的很快，因此并不会出现p2更新了数字，p1读了旧的数字并将该数字更新到了和p2更新后同样值的情况。参考数据库的脏读。\n有点抽象，举个例子：\ntxtp2:  读出counter: 10000  然后+ 1 = 10001\np1： 读出counter: 10000  然后+ 1 = 10001;那这样就等于白操作了。\n2.8 Persistence\n\n\n\n\n\n\n\n\nPersistence: Access information permanently\n\n信息的寿命比任何一个线程都要长\n机器出现未预期的重启、断电。这时候就体现出持久化的重要性了\n\n持久化需要：\n\n确保出现unexpected failure的时候，信息能够正确的存储\n提供Abstraction使得进程不知道数据是如何存储的\n因为磁盘IO很慢，我们需要对持久化进行优化\n\n2.8.1 OS 在持久化过程中做了什么？\n搞清楚新的数据在disk的那一块存放\n向底层（underlying）存储设备（storage device）发出I&#x2F;O 请求\n文件系统（FileSystem）在IO期间处理崩溃\n\n2.8.2 两种持久化策略：\nJournaling\n\n日志文件系统： 一种文件系统，在将这些更改提交到主文件系统之前，使用日志记录对文件系统的更改\n运行流程：\n对文件系统的更改首先记录在日志中\n更改成功写入日志后，将其提交到主文件系统\n当系统出现崩溃或故障时，可以通过重放日志来恢复文件系统。日志中记录的任何不完整或不一致的操作都可以完成或撤消，以维护文件系统的完整性。\n崩溃后恢复速度更快\n数据完整性得到保证\n\n\n例子： ext3、ext4\n\n\nCopy on write\n\n写入时不直接对原位置的数据进行修改，而是写入新的位置\n原数据将一直保存，直到写入完成\n运行流程：\n当需要读取数据时，首先从当前位置读取数据\n在新位置制作数据的副本\n对副本进行修改\n最后将只想原数据的指针更新指向新数据的副本\n\n\n优点：\n简化了崩溃后的恢复。因为在修改完成前的原始数据不会受到影响\n提供了任何给定时间点的一致数据快照\n\n\n例子： 一些现代化的文件系统，如ZFS、Btrfs\n\n\n\n3 CPU Virtualization\n\n\n\n\n\n\n\n\n从本章开始，我们正式开始讨论虚拟化的第一个主题： CPU 虚拟化本章会解决以下问题：\n\nWhat is a process?\nWhy is limited direct execution a good approach for virtualizing the CPU? \nWhat execution state must be saved for a process? \nWhat 3 modes could a process in?\n\n3.1 What is process?\n\n\n\n\n\n\n\n\nProcess: An execution stream（执行流） in the context（上下文） of a process state\nexecution stream    * A stream of executing instructions    * Running piece of code    * Thread of control (其实和execution stream一个意思。单线程的话就是执行流嘛。然后多线程的话，每个线程都有自己的执行流。)\n执行流指的是计算机程序正在执行的指令的顺序流。代表着一段指令是活动的。\n\n说人话，就是正在跑的程序，这个程序得是活的，而不是在磁盘上的静态文件。在跑的过程中，CPU会直接处理这些指令序列\n\n补充一下： CPU全名central processing unit。别学了半天OS，CPU到底是个啥都不知道。。\nprocess state    * Everything that the running code can affect or affected by    * Register        * Heap, General Purpose, floating point, stack pointer, program counter    * Memory Spaces    * 例子： Open files\n\nprocess is not program!\nprogram是静态的代码和数据\nprocess是动态的代码和数据\n可以有多个process运行同一个program\n\n\n\n3.2 Process Management Segments\nOS 会为每个进程分配memory。\n这个memory，包含了很多的块(segment)\n从上到下来看\n最高层是 stack，用于存储局部变量。也包括command line arguments（位于顶部）， 以及环境变量\n再往下走是Heap。用于动态的memory。 在stack和heap之间，有一块unused segment，用于stack&#x2F;heap的扩容\n.bss Global Uniniialized Variables（全局未初始化变量）\n.data Global Initialized Variables（全局已初始化变量）\n最底层才是code。Read-Only\n\n\n\n3.3 Process vs. Thread很明显，进程肯定不是线程\n但是他们还是有相似之处的，我们可以把线程看作一个轻量版 的process（Light weight Process LWP）。\nThread is a execution stream that shares an address space一个进程里存在多个线程\n举个共享内存空间的例子。对于进程来说，两个相同程序的不同进程，当他们都在access同一个地址值的时候，他们得到的结果不一样 （内存虚拟化）而对于线程，一个进程内的多个线程，当他们都在access同一个地址值的时候，他们得到的结果是一样的\n对于进程，我们的目标是： 让每个进程都感觉，自己是独占cpu的。\n3.4 Resources Sharing了解了目标后，我们先看一下OS是怎么分配资源(resources)的\n首先， 资源分配通分为两种：    1. time sharing    2. space sharing\n\n\n\n\n\n\n\n\n\ntime sharing 主要针对的是单CPU的情况。 使多个用户或进程能够共享单个处理器。具体做法是：将可用的处理时间划分为多个小的时间间隔（timeslice），并且将这些时间片分配给各个用户&#x2F;进程。从而打到各个用户&#x2F;进程公平分配资源的效果，并且在他们各自分配的时间片内，能够独享cpu\n\n关si键词： 公平、快速切换（illusion of multaneous execution）\n\n\n\n\n\n\n\n\n\n\nspace sharing 关注的是空间上的共享&#x2F;复用。每一个进程都被分配CPU容量的一小部分。\n\n关键词：并行（Parallel）执行， 同时执行（real simultanous execution）， 资源隔离（resource isolation）\n\n在共享时，我们主要注意两点：\n\ncannot perform restricted operation\nshould not run forever or make the entire system slow &#x3D;&gt; performance\n\n###3.5 Provide Good CPU Performance\n\nDirect Execution\n直接让用户操作硬件： CPU只负责创建并初始化进程，之后的控制权就回到起点（比如main()），交给用户手中了。\n\n\n\n这样子用户进程的权限就过大了。因此Direct Execution肯定是有问题的：\n\n进程（Process）可以做一些受限（restricted）的事情\n\n比如读取&#x2F;写入别的进程的数据\n\n\n进程可以永久执行（缓慢，有漏洞，恶意（malicious））\n\nOS 需要在进程之间交换(swap)的能力\n\n\nOS很多操作很慢： 比如I&#x2F;O  还是进程切换能力\n\n\n根据以上问题，我们可以给出一个折中的解决方案: 让OS和Hardware保留一些控制权。\n3.5.1 Restricted OpsQ1: 我们如何确保用户进程不会单方面（unilaterally）执行受限(restricted)的操作呢?\n解决方法： （权限级别&#x2F;分离）privilege levels&#x2F;separation\n\n如果想要直接和设备进行交互， 那就用kernal mode，这样就不受限制了。\n\n对于用户进程，就在user mode下执行。如果试图和设备进行直接交互，就会进陷阱（trap），然后software interrupt\n\n如果用户进程想和设备进行交互的话，可以通过以下方式：\n\nSystem Calls (由OS实现的方法)\nChange Privilege Level（权限级别）through system call（trap）\n\n\n\nSystem call demo: 1 direct system call &amp; 1 system call provided by libc function.\nc#include &lt;stdio.h&gt;\n#include &lt;stdlib.h&gt;\n#include &lt;unistd.h&gt;\n#include &lt;sys/syscall.h&gt;\n\nint main(int argc, char *argv[]) &#123;\n    long ID1, ID2;\n    ID1 = syscall(SYS_getpid);\n    printf(&quot;direct system call, pid = %ld\\n&quot;, ID1);//direct system call, pid = 3565265\n    ID2 = getpid();\n    printf(&quot;libc wrapped system call, pid = %ld\\n&quot;, ID2);//libc wrapped system call, pid = 3565265\n&#125;3.6 System Call Table and Trap Table\n\n\n\n\n\n\n\n\n前面讲到过，系统调用表和陷阱表之间存在映射。用于管理用户引发的系统事件。主要得知道怎么通过汇编，对系统调用表和陷阱表进行分析，从而得出系统时间的结果。\nCPU使用EAX寄存器（register）的内容作为源操作数。窍门就是看$后面的数字内容，找系统调用表和陷阱表上数字对应的操作就行。\n比如这道题：\ntxt\nSuppose the trap table on a machine looks like the following:\n\n1 - illegal; call OS process kill routine\n\n2- run OS system call routine\n\nSuppose the OS&#39;s system call table looks like the following.\n\n1 - sys_read()\n\n2 - sys_write()\n\nWhat happens when an application performs the following instructions?\n\nmovl $1, %eax\n\nint $1前面的1是system call表里的，后面的int $1是trap表里的。所以结果就是kill runtime.movl -&gt; 放进eax， int -&gt; 产生软件中断。\n总结一下，user processes 是不被允许直接 perform：\n\narbitrary memory access\nDisk I&#x2F;O\nSpecial x86 instructions like lidt. (Inteterrupted Discription Table)\n\n如果user processes做了上面的事情，那么大概率就是进了trap，然后kill routine。\n3.7 How to take CPU away?\n\n\n\n\n\n\n\n\nOS 需要实现多任务处理（multitasking）。先记住一个词上下文切换。后面会重点围绕这个概念来讲\n\nMechanism： To switch between classes\nPolicy: To decide which process to run at what time.\n\nMechaism 和 Policy的区别？\n\n\n\n\n\n\n\n\n\nPolicy: Decision-maker to optimize some workload performance metric    * Which Process to run? When to run? &#x3D;&gt; schedulerMechanism: Low-level code that implements the decision    * How ? &#x3D;&gt; Dispatcher\n在这里，我们先将Dispatcher\nDispatch 的逻辑很简单\ncwhile (1) &#123;\n    run process A for some time slice\n    stop process A and save its time\n    load context of another process\n&#125;问题是：    1. dispatcher怎么在一段时间后，重新获得控制？    2. 哪些execution context必须被保存并恢复？\n3.7.1 Q1:dispatcher怎么在一段时间后，重新获得控制？\n\n\n\n\n\n\n\n\nOption 1 : Cooperative Muti-tasking通过trap，将CPU移交给操作系统的信任线程    * 例如： System Call， page fault（想要换取的page不在main memory里）或者 error    * yield()但是，这样子的话也有问题。设想一个process，它没有任何越过自身权限的操作（I&#x2F;O）， 也没有进任何的Trap，也没有自己叫yield(),那么最终，这个process就会一直占着整个机器。唯一办法只有重启。\n这时候就有了第二种选项\n\n\n\n\n\n\n\n\n\nOption 2: Regain control without cooperation我们可以启用周期性的，时钟。进入OS的时候，我们启动时钟，，时钟时间到后，硬件会生成timer interrupt用户也不能屏蔽掉timer interrupt，因为他们没有权限这样子做。\n3.7.2 Context save在哪里？\n\n\n\n\n\n\n\n\nprocess control block (PCB) 也可以叫做 process descriptor (PD)每个进程都会有PCB\n3.7.2.1 PCB 存储了哪些信息\nPID\nProcess state (I.e., running, ready, or blocked)\nExecution state (all registers, PC, stack pointer) – Context\nScheduling priority\nAccounting information (parent and child processes)\nCredentials (which resources can be accessed, owner)\nPointers to other allocated resources (e.g., open files)\n\n3.7.2.2. Context 保存&#x2F;切换流程\n进程A从user mode 转换到 kernal mode，权限提升。OS决定从A转到B\n在kernal stack上保存A的上下文（PC， registers， kernal stack pointer）\n将stack pointer指向进程B的kernal stack\n从B的kernal stack中恢复上下文\n\ncstruct context &#123;\n    int eip;\t// Index pointer register\n    int esp;\t// Stack pointer register\n    int ebx;\t// Called the base register\n    int ecx;\t// Called the counter register\n    int edx;\t// Called the data register\n    int esi;\t// Source index register\n    int edi;\t// Destination index register\n    int ebp;\t// Stack base pointer register\n&#125;;\n一些进程在执行不需要Cpu的任务的时候，OS会switch到哪些需要CPU的进程为了完成这个功能，OS必须关注进程的状态\ncenum proc_state &#123; UNUSED, EMBRYO, SLEEPING,\n                  RUNNABLE, RUNNING, ZOMBIE &#125;;Running: 占用cpuReady： 等待CPUBlocked：正在等待同步或者I&#x2F;O.\n4. Scheduling4.1 两种创建Process的方式\nNew process from sratch (从0构建)\n\n\n步骤\n从memory中加载指定代码和数据；并创建空的call stack\ncreate and initialzie pcb\nput process on ready list.\n\n\n\n好处：定制化，no waste work坏处： 很难涵盖所有可能的options for setup. 比如WindowesNT有10个参数，这咋搞。\n\n第二个方式： Clone an existing project and change it.Fork(): 克隆调用者\n停止目前的进程，保存他的状态\n复制代码的stack，code ,data, pcb\n将PCB放进ready listExec (char *file): exec覆盖调用进程\n替换掉目前的代码和数据\n\n\n\ndemo: Base shell program\ncwhile (1) &#123;\n    Char *cmd = getcmd();\n    Int retval = fork();\n    If (retval == 0) &#123;\n        // This is the child process\n        // Setup the child’s process environment here\n        // E.g., where is standard I/O, how to handle signals?\n        exec(cmd);\n        // exec does not return if it succeeds\n        printf(“ERROR: Could not execute %s\\n”, cmd);\n        exit(1);\n    &#125; else &#123;\n        // This is the parent process; Wait for child to finish\n        int pid = retval;\n        wait(pid);\n    &#125;\n&#125;4.2 Dispatcher 和 Scheduling 区别\n\n\n\n\n\n\n\n\nDispatcher是一个low level 的mechanism 而 Scheduling是policy\nScheduling: Policy to determine which process gets CPU when\n重点： How to transition?\t(“mechanism”)      When to transition?\t(“policy”)  \n一个用于理解的例子：文件IO   Process alternates between CPU and I&#x2F;O process moves between ready and blocked queues\n一些术语Workload: set of job descriptions (arrival time, run_time)    * Job: View as current CPU burst of a process\nMetric: measurement of quality of schedule    * Minimize turnaround time         Do not want to wait long for job to complete         Completion_time – arrival_time （process&#x2F;thread complete - process&#x2F;thread add to runqueue）    * Minimize response time        * Schedule interactive jobs promptly so users see output quickly        * Initial_schedule_time – arrival_time （process&#x2F;thread add to runqueue - process&#x2F;thread scheduled）    * Maximize throughput        * Want many jobs to complete per unit of time    * Maximize resource utilization        * Keep expensive devices busy    Minimize overhead        * Reduce number of context switches    Maximize fairness        * All jobs get same amount of CPU over some time interval\n4.3 一些 Scheduler\n\n\n\n\n\n\n\n\n在考虑Workload的情况下，我们需要考虑这些是否达成\n\nEach job runs for the same amount of time\nAll jobs arrive at the same time\nAll jobs only use the CPU (no I&#x2F;O)\nRun-time of each job is known\n\n4.3.1 FIFOFIFO: First In, First Out\t    - also called FCFS (first come first served)     - 根据arrive time来干活    - ABC同时到，先干A，A好了的同时马上干B    - turn_around &#x3D; completion_time - arrival_time\n计算题： 算一下avg_turn_around_time:    \n显然FIFO是不满足第一条的， 每个Job跑的时间都不一样。从而导致，metric中的turnaround会很高\n如果第一个来的job非常的time-consuming，那么就会导致，后面那些原本能够很快就完成的job，被堵着（阻塞）。\n这里的平均turnout_time就达到了 (60 + 70 + 80) &#x2F; 3 &#x3D; 70s 而原本有的任务只需要10s就可以完成。\n根据FIFO的缺点，我们就可以设计出第二种似乎更好的Scheduler。 Shortest Job First（SJF）\n4.3.2 SJF\n\n\n\n\n\n\n\n\n选择run_time最小的job\n计算1： 对于这个例子，平均turnout time是多少呢\n(10 + 20 + 80) &#x2F; 3 &#x3D; 36.7\n计算2： 对于这个例子，平均turnout time是多少呢turn_around &#x3D; completion_time - arrival_time记住这个公式，就很好算了。\n可以看出，FIFO和SJF都是非抢占式（non-preemptive）的。只有当任务执行完毕，或者优先级不够的情况下，才会让出CPU。\n抢占式（preemptive）的CPU则相反。就算你的job已经在执行了，万一来了个比你正在执行的job更牛的job，则会schedule更牛的job，你正在运行的job失去了CPU，在旁边等着\n4.3.3 STCF\n\n\n\n\n\n\n\n\nShortest time-to-completion First永远执行会完成最快的任务。\n计算：平均turnaround time(80 - 0) + (20 - 10) + (30 - 10) &#x3D; 80 + 10 +  20 &#x3D; 110110&#x2F;3 &#x3D; 36.6s很明显在这种情况下，抢占式的turnout time会比非抢占式的快很多\n4.3.3.1 Response Time\n\n\n\n\n\n\n\n\n有时候，从任务到达到任务开始的这段时间也很重要。我们将这段时间称为：Response Timeresponse_time &#x3D; first_run_time - arrival_time\njob b在10s的时候到。turnaround time &#x3D; 30 - 10 &#x3D; 20sresponse time &#x3D; 20 - 10 &#x3D; 10s\n4.3.4 RR\n\n\n\n\n\n\n\n\nRound Robin在response time方面比STCF、SJF、FIFO做的都好因为它会每一段时间就会交替状态为Ready的进程，从而每个job第一次开始run的时间不会差距不会特别大。\n\n当前，有得必有失。RR在turnaround time上非常慢。因为job是交替执行的，原本能很快结束的job被迫得隔一段时间就让出CPU。通常，我们选择RR的原因是因为我们不知道每个job的run time。选择rr的目的和stcf、sjf一样，都是为了让能够最快完成的进程，有机会最早做到。\n4.3.5 MLFQ\n\n\n\n\n\n\n\n\nMulti Level Feedback Queue\n不同类型的job，要求也不一样\n\n交互性的（interactive）program，需要更快的response time\n批处理（batch）program，需要更快的turnaround time。\n\nMLFQ 基于多层的RR（Round Robin）实现。每层都有更高的优先级，并会抢占低优先级的层数。\n4.3.5 决定优先级两种方式能够用来决定优先级。\n\nHistory\n\n\n\n\n\n\n\n\n使用进程过去的behavior来预测未来的behavior根据此进程过去的 CPU 突发（作业），猜测 CPU 突发（作业）的行为方式\n\n\n4.3.6 MLFQ Rules\nIf priority(A) &gt; priority(B), A runs\nIf priority(A) &#x3D;&#x3D; priority(B), A and B runs in RR\nProcess start at the top priority\nIf job uses the full timeslice, then demote process\n\nMLFQ 的小缺陷低优先级的任务可能永远都不会被scheduled。因此，我们需要每隔一段时间就去将所有的job放到最高优先级的队列中。\n4.3.6 Lottery Schedudling就和它的名字一样。彩票。目标： fair share\n\n只关心能否公平地分享CPU\n\nFair Scheduler:: Guarantee that each job obtain a certain percentage of CPU time. Not care about response time or turnaroud time实现逻辑也很简单： 给processes 一张彩票，谁中了谁就run。更高的优先级说明拿到了更多的彩票。\nTicket: 代表了一个process可以占用多少份额的资源。\n比如 Process A拿了75张票，那就占用75%的CPU。 Proess B拿了25张票，那就占用25%的CPU然后Scheduler就会在这100张票里去抽，抽中哪一个数字，就执行手里握着那个数字的线程任务。\nlottery 算法的实现\ncint counter = 0;\nint winner = getrandom(0, totaltickets);\nnode_t *current = head;\n\nwhile (current) &#123;\n    counter += current-&gt;tickets;\n    if (counter &gt; winner)\n        break;\n    current = current-&gt;next;\n&#125;\n// current is the winner\n\n4.3.7 Stride Scheduling目标同样是为了防止任何线程monopoly CPU。\nThe basic idea is assign each process a ‘stride’, which represents its priority or share of the CPU time. \n系统中的每个进程都被分配了一个唯一的步长值。步幅与进程的优先级成反比。优先级较高的进程分配较小的步幅，优先级较低的进程分配较大的步幅。目标是让优先级较高的进程更频繁地访问 CPU。\n同样，进程会被放进一个队列。所有进程自身的counter从0开始。每次自己被执行了，就将自身的counter 翻一翻（counter + stride）。 Scheduler会选择具有最小counter的process。\n\nStride Scheduling同样也存在问题：\n对于新增job，很难确保公平性和优先性。因为每个job，在初始状态下，counter都是0.问题是，当这些线程执行了一段时间后，counter就会变得很大，起码会和0差很多。那么新的job加进来，scheduler必然会判定一直让新job占用cpu，这样就不公平了\n就算不考虑新增。如果你想手动更改process的优先级，又该怎么做呢\n\n\n\n4.3.8 Complete Fair Scheduling很显然Stride Scheduling可以确保一定的完整性，但是不能完全确保完全公平\n我们的目标是无论线程数量的大小，无论何时添加、更改线程，都能保证其公平地使用资源\nComplete Fair Scheduling(CFS) 自从Linux 2.6.23 版本被应用。 O(logN) runtime原本是MLFQProcess now ordered by the amount of CPU time they use取代了队列，转而使用红黑树\n\nCFS核心概念\n使用一个counter记录累计执行时间（cummulative execution time）\nSchedule process with least runtime\n\n\n\n下面这些都是gpt对其的介绍\n\n虚拟运行时间：\n\nCFS为每个可运行的进程维护一个“虚拟运行时间”。虚拟运行时间表示一个进程等待执行的时间相对于其他进程。较小的虚拟运行时间值表示更高的优先级。\n\n\n调度决策：\n\n选择具有最小虚拟运行时间的进程进行执行。这确保了等待时间较长或累积CPU时间较短的进程被优先考虑。\n\n\n时间量子：\n\nCFS不使用固定的时间片或时间量子，而是根据可运行进程的数量和它们的虚拟运行时间动态调整时间量子。\n\n\n动态时间量子计算：\n\nCFS根据进程的权重计算每个进程的时间量子。权重是分配给每个进程的值，表示它在CPU中的份额。较高的权重导致较大的时间量子。\n\n\n权重和Nice值：\n\n进程根据其优先级被分配权重。用户进程可以使用“nice”值进行优先级调整，该值范围从-20到+19。较低的nice值表示较高的优先级。权重与nice值成反比。\n\n\n平衡机制：\n\nCFS采用平衡机制来维持随时间的公平性。它定期检查运行队列，如果检测到不平衡，则重新分配负载。这有助于确保没有进程在CPU时间上被不公平地耗尽。\n\n\n稳态公平性：\n\nCFS旨在实现稳态公平性，这意味着在更长的时间内，每个进程都能获得其公平份额的CPU时间，而不考虑短期波动。\n\n\n红黑树数据结构：\n\nCFS中的运行队列使用红黑树数据结构实现。这允许根据它们的虚拟运行时间有效地插入和删除进程。\n\n\n\n\n5. Muti-core Scheduling\n\n\n\n\n\n\n\n\n由于多核处理器的兴起，多核调度成为必须。因为单单添加CPU的数量不会让一个应用程序执行地更快。我们需要重写应用程序以保证其能并行执行\n5.1 单CPU + 缓存 + main memoryCPU分出一篇区域给缓存，存放popular data found in main memory. 速度块，容量小Main memory存放所有数据，从main memory获取数据的速度会比cache慢很多\n5.2 多CPU情况简单来说，每个CPU都有一个缓存区域。那两个CPU加起来就有两块缓存区域了。\n同步不同缓存区域的内存看起来很简单： CPU0 将memory中的 数据放进了自己的缓存区，CPU1会读取CPU0的缓存区，同步数据。\n但是，有一种特殊情况：    1. CPU 0 读内存放进缓存，CPU1 读到了共享。    2. CPU 0 更新了缓存中的数据 同时 CPU 1 被schedule了    3. 此时 CPU 1 中保存的还是过去的数据。数据就不一致了\n解决方法很简单： Bus Snooping    * 每个cache都会通过观察bus来注意到memory的更新    * 当CPU注意到自身memory中的数据更新了，就会注意到这个变化\n5.3 Cache Affinity\n\n\n\n\n\n\n\n\n无论是多CPU还是单CPU，Scheduler都会尝试将一个进程放在同一个CPU上执行。因为当CPU在执行该线程时，会往缓存里加很多关于改进程的状态。那么等到改进程下次启动时，就会更快一点，因为缓存里已经有信息了\n实现方式：将所有需要scheduled的任务全部放在一个队列里面。每个CPU就从这个Globally Shared的队列里面拿job。\n坏处：    1. 锁    2. 扩展性缺少    3. Cache Affinity    4. 实现起来复杂\n5.4 Multi-queue Multiprocessor Scheduling (MQMS)\nContains Multiple Scheduling queues\n每条队列都有自己的Scheduling Discipline\n当job进入系统的时候，只会放在一条队列上， 从而避免了信息共享（information sharing）和 同步（synchronization）的问题\n\n\n\nMQMS with Round Robin\nMQMS的问题： 需要通过跨内核迁移进程来平衡跨内核的负载\n6. Virtualizing Memory目标： \n\nTransparency\nProcesses are not aware that memory is shared\nWorks regardless of number and&#x2F;or location of processes\n\n\nProtection\nCannot corrupt OS or other processes\n\n\nPrivacy\nCannot read data of other processes\n\n\nEfficiency\nDo not waste memory resources (minimize fragmentation（碎片化）)\n\n\nSharing\nCooperating processes can share portions of address space\n\n\n\n6.1 Abstraction: Address Space\n\n\n\n\n\n\n\n\nAddress space: Each process has set of addresses that map to bytes\n问题是：OS是如何让每个Process觉得，自己有专用的地址空间的？\n** 回顾 Addresss Space 中都有什么？ **\n\n静态：\nCode\nGlobal Variables\n\n\n动态：\nStack\nHeap\n\n\n\n6.1.1 为什么进程需要动态地分配资源？\n\n\n\n\n\n\n\n\n\n不知道编译时需要的内存量. 静态分配内存时必须悲观, 为最坏的情况分配足够的资源;不高效地使用存储\n对于那些递归的步骤，不知道会嵌套多少次\n进程中会有复杂的数据结构，需要我们手动分配资源。\n\n6.1.2 Stack用在哪里？\n\n\n\n\n\n\n\n\n操作系统将Stack用于过程调用帧(procedure call frames), 存放local varibles and parameters局部变量例子\nc#include &lt;stdio.h&gt;\n\nvoid foo(int z);\n\nint main(int argc, char *argv[]) &#123;\n    int A = 0; \n    foo(A);\n    printf(&quot;A: %d\\n&quot;, A); //A: 0\n&#125;\n\nvoid foo(int z) &#123;\n    int A = 2;\n    z = 5;\n    printf(&quot;A: %d, Z: %d\\n&quot;, A, z); //A: 2, Z: 5\n&#125;6.1.3 Heap用在哪里？\n\n\n\n\n\n\n\n\n任何位置的malloc(), new() 都会跑到heap里\n\nHeap memory consists of allocated area and free area\nOrder of Allocation and free is unpredictable.\n\npro：所有数据结构都是这样用的cons:    * Allocation can be slow    * End up with small chunks of free spaces – Fragmentation(碎片化)\n6.1.4 OS在managing heap中的作用\n\n\n\n\n\n\n\n\nOS gives big chunk of free memory to processOS provides library manages individual allocations\n代码中各个数据结构在address space中的分布\n6.2 如何虚拟化Memory\n\n\n\n\n\n\n\n\n问题：如何同时运行多个进程\n我们知道进程中的addressess是硬编码进进程的binary里的。然而，因为进程已经产生了自己独享memory的错觉，当多个进程同时运行时，很有可能出现多个进程试图操作同一内存区域的问题。\n解决这些问题的方法有：\n\nTime Sharing\nStatic Relocation\nBase\nBase+Bounds\nSegmentation\n\n6.3 Time Sharing of Memory\n\n\n\n\n\n\n\n\n属于比较少见的做法，甚至概念也很少提及\nOS通过在进程不在运行时，将CPU registers放入memory，给了进程一种有很多虚拟cpu的幻觉同样，我们也可以在进程不在运行的时候，把内存放进磁盘。这样进程就会感觉独占memory。\n但是，我们知道Disk I&#x2F;O是一个非常费时、低效的过程。所以这个法子性能非常差\n6.4 Space Sharing - Statis Relocation\n\n\n\n\n\n\n\n\n比Time Sharing会好一点\nOS在进程加载进内存之前，重写每个程序，这样子不同的进程就会使用不同的地址和指针了。\n但是没有保护，可能会出现地址出问题的情况，进而：1.破坏OS2.破坏其他进程3.并且会产生虚有的IO4.没有隐私5.一旦分配地址之后，就不能移动地址了。从而不能够allocate new proceess\n6.5 Space Sharing - Dynamic Relocation\n\n\n\n\n\n\n\n\nGoal： Protect processes from one another\nRequire hardware support    * Memory Management Unit (MMU)\nMMU会在每个内存引用处动态地改变进程的地址    * 进程生成逻辑（虚拟）地址，交给MMU    * MMu 将其转换成物理（真实）地址，存入内存\n\nMMU两种运行模式：\n\nPriviledged:    1.有OS运行    2.可以操作MMU中内容和    3.一般是通过trap、system call来运行\n\nUser mode：\n\n主要是为了translate 虚拟地址到物理地址\n\n\n\nMMU为了转移，有base register。base: start location for address space\n\n可以注意到user mode 里面，往logical address上面加了base。个人理解： 是为了限制user，只能访问base上面的地址。\n6.5.1 Dynamic Relocation with Base RegisterIdea: 在虚拟内存转换成物理内存的过程中，设一个偏移量。将这个偏移量存在base register上。每个进程的偏移量都不一样。\n6.5.2 Base Register + Bound\n\n\n\n\n\n\n\n\n单凭Base Register, 如果一个线程不停的往上&#x2F;下 加减他的memory address，那么总有一天，他会和别的进程的memory space发生碰撞。这样一来，protection又没了\n\nBound register： size of this process’s virtual address space\n有时候会是 base + size （一个进程最大的物理地址）\n\n\n\nOS will kill the process if process loads&#x2F;stores beyond bounds\nTips:Register中包含    1. base 32bit        2. bound 32bit        3. mode 1bit\n判定流程\nInterrupt示例\n6.5.3 Base + Bound时对进程的管理\n\n\n\n\n\n\n\n\n谈到进程管理，主要涉及到的时上下文切换（context-switch）当执行上下文切换的时候，我们要将Base &amp; Bound Register 添加到 Process Control Block中的 context中\n\n步骤\nChange Privileged mode\nsave base &amp; bound registers of old process\nload base &amp; bound registers of new process\nChange to user mode to jumo to new process\n\n\n\n从上面的步骤，我们可以看出，user process不能操作base &amp; bound registers，并且也不能切换到Privileged mode\n6.5.4 Base + Bound + Dynamic Relocation 的好处：\nProvides protection (both read and write) across address spaces\nSupports dynamic relocation\nCan place addresses places initally at locations different from assumed in the memory\nCan move addresses spaces if needed\n\n\nSimple, inexpensive implementation\nFast\nadd and compare in parallel\n\n\n\n6.5.5 Base + Bound + Dynamic Relocation 的坏处：txt* 每个进程都必须连续地分配在物理内存中\n* 必须得分配一些不能被process用到的内存。\n* No Paritial Sharing.(Implication of isolation)6.6 Segmentation Addressing（分段寻址）\n\n\n\n\n\n\n\n\nBase and Bound 的加强版将地址空间分割成若干个逻辑块， 每个逻辑块对应地址空间中的逻辑实体\n\ncode， heap， stack特性：\n\n每个实体都可以placed seperately on the physical address\n每个实体都可以扩展和伸缩\n每个实体都受到了保护（seperate read&#x2F;write&#x2F;exec bits）\n\n\n\n\n\n\n\n\n\n\n\n\n在操作系统（OS）中，分段寻址（Segment Addressing）是一种内存管理的方法，其中内存被划分为多个不同大小的段（segments），每个段用于存储特定类型的数据或执行特定的任务。每个段都有一个唯一的标识符，称为段描述符，它包含有关段的信息，例如起始地址、段的大小和访问权限等。\n以下是关于操作系统中分段寻址的解释：\n段描述符：在分段寻址中，每个段都由一个段描述符表示。段描述符存储了与段相关的信息，如起始地址、段的大小、访问权限、以及其他控制信息。这些描述符通常存储在特殊的表中，例如全局描述符表（Global Descriptor Table，GDT）或局部描述符表（Local Descriptor Table，LDT）。\n逻辑地址：逻辑地址由两个部分组成：段选择器和偏移量。段选择器用于选择段描述符，而偏移量表示从选定段的起始地址开始的位置。通过组合这两部分，可以构成完整的逻辑地址。\n段寻址过程：当程序引用一个逻辑地址时，操作系统通过分段寻址来确定对应的物理地址。首先，根据逻辑地址中的段选择器，操作系统找到相应的段描述符。然后，使用段描述符中的起始地址和逻辑地址中的偏移量来计算物理地址。\n优势：分段寻址的主要优势之一是可以更灵活地管理内存，因为不同的段可以有不同的大小和访问权限。这有助于更好地组织和保护内存中的数据和代码。\n保护机制：\n通过分段寻址，可以实现内存保护机制。每个段描述符都包含有关访问权限的信息，如读、写、执行权限。这样，操作系统可以确保程序只能访问其具有权限的段。\n虚拟内存：分段寻址也有助于实现虚拟内存。不同的段可以映射到物理内存的不同区域，而不同的程序可以共享相同的段，使得虚拟内存的管理更加灵活。\n需要注意的是，现代操作系统通常采用更先进的内存管理机制，如分页寻址（Paging），而不仅仅是分段寻址。这些机制可以更好地支持虚拟内存、内存共享和更高级的内存保护。\nSegmentation Addressing的缺点\nFragmentation，太多scattered的segment\n\n6.7 Paging\n\n\n\n\n\n\n\n\n前面说过，分段寻址的问题在于fragmentation太多。我们的目标就是降低对于连续空间的要求\n\nreduce external fragmentation\ngrow segment as needed\n\n思路：我们可以将address space和physical memory分成固定大小的page\n\nSize 2^n， e.g. 4kb 8kb 16kb  etc..\nPhysical Page: page frame\n\n一些计算题公式\n\n已知number of bits for vpn（virtual page number）， 问多少virtual page？\n\n\n\n\n\n\n\n\n\n\n2^number of bits for vpn\n\n已知bits in virtual address and bits for offset, 问virtual page number有多少bits？\n\n\n\n\n\n\n\n\n\n\nbits in virtual address - bits for offset\n\n已知Page Size， 问offset需要多少bits？\n\n\n\n\n\n\n\n\n\n\nlog2(page_size)\n\n\n\n","slug":"OSD","date":"2023-10-28T17:11:23.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"0a779d0e741d0e316d7b9d9aa44bdfc9","title":"SQL查漏补缺","content":"SQL查漏补缺\n\n\n\n\n\n\n\n\n记录一下SQL刷题时候遇到的知识点漏洞\n1. SQL !&#x3D; 和 &#x3D;&#x3D; 的适用场景\n\n\n\n\n\n\n\n\n– SQL 中，!&#x3D; 和 &#x3D;&#x3D; 只能用于数字判断，对于空值， 需要用 is， is not 来判断\n\n584. Find Customer Referee\n\n2. 计算日期差值datediff(date1, date2) \n结果为date1 - date2\n\n197. Rising Temperature\n\n3. left&#x2F;right join必须要on条件，而inner join不需要4. where&#x2F;having&#x2F;join on区别先看一下SQL的执行流程：\n\n\n\n\n\n\n\n\n\n第一步：from 选择表\n第二步：where 筛选条件，筛选对象–行\n第三步：group by 将筛选出来的数据进行分组\n第四步：having 筛选条件，筛选对象–组\n第五步：select 选取最后的结果\n第六步：order by 将结果按照特定顺序排列\n\n\n\n\n\n\n\n\n\n“where” 是一个约束声明，使用Where来约束来之数据库的数据，Where是在结果返回之前起作用的，且Where中不能使用聚合函数。\n“Having”是一个过滤声明，是在查询返回结果集以后对查询结果进行的过滤操作，在Having中可以使用聚合函数。\n\nHaving里面不能用列名，只能用数值和聚合函数的对比。\n\n\n\n\n\n\n\n\n\n在 SQL 查询中，当你使用 GROUP BY 语句对结果进行分组时，除了被聚合的列（使用聚合函数如 MIN、MAX、AVG、SUM 等）之外，其他列的值将不明确。这些未被聚合的列通常需要通过聚合函数或者放入 GROUP BY 子句中，以明确它们在每个分组内的值。\n所以，当你在 HAVING 子句中使用 order_date 而不是聚合函数，就是指 order_date 是未被聚合的列。HAVING 子句用于过滤基于聚合的结果，而未被聚合的列在这个语境下不是直接可用的。\n举例来说：\nsql-- 有效的查询，因为 COUNT 是一个聚合函数\nSELECT customer_id\nFROM Delivery\nGROUP BY customer_id\nHAVING COUNT(*) &gt; 1;sql-- 无效的查询，因为 order_date 是未被聚合的列\nSELECT customer_id, order_date\nFROM Delivery\nGROUP BY customer_id\nHAVING order_date = MIN(order_date);在第二个查询中，order_date 是未被聚合的列，而 HAVING 子句中的条件要求使用 MIN(order_date)，这就是为什么会报错的原因。解决方法通常是通过子查询或者连接操作来获取你需要的结果。\n\n\nMysql报错：group function is not allowed here在where和on中，我们不能使用聚合函数。因为on和where都是针对行的筛选。而聚合函数，很明显是对于整张表上的数据的统计。\n所以，当你将聚合函数的判定放在where和on中，会报错。因为你没办法对一个行进行统计。\n聚合函数的判定，放having里。因为having是用来对结果集进行筛选的\n\n570. Managers with at Least 5 Direct Reports\n\n5. Mysql中if的用法\n\n\n\n\n\n\n\n\n常用sum内嵌套if\nsum(if (aaa &#x3D; ‘xxx’, 1, 0))\n算平均值时，除数是0，结果为null。但是需要把null改成0。怎么改？\n\n\n\n\n\n\n\n\n使用nullif\nnullif(1&#x2F;0,0)\n\n1934. Confirmation Rate\n\n6. 统计字符串长度\n\n\n\n\n\n\n\n\nchar_length或者len\n\n1683. Invalid Tweets\n\n7. SQL判断字段奇偶\n\n\n\n\n\n\n\n\nmod(字段, 2) &#x3D; 1  或&#x3D;0   \n\n620. Not Boring Movies\n\n8. SQL 判断日期是否在区间内\n\n\n\n\n\n\n\n\n 两种办法\n\n用BETWEEN AND\n\nsqlSELECT *\nFROM table_name\nWHERE date_column_name BETWEEN start_date AND end_date;\n用大于小于\n\nsqlSELECT *\nFROM table_name\nWHERE date_column_name &gt;= start_date AND date_column_name &lt;= end_date;\n\n1251. Average Selling Price\n\n9. Mysql中的sum\n通常配合groupby使用，在sum中，只要是对单行操作，都可以。比如可以是sum(同一行的价格 * 数量) , 就能求总价\n10. Mysql日期的截断\n\n\n\n\n\n\n\n\n正常datetime都是yy-mm-dd 这种格式构成的，如果我们只要yy-mm这一部分，怎么做呢。\n使用 DATE_FORMAT(get_date, ‘%Y-%m-%d’) 函数截取。\n其中：get_date 是需要截取的字段名；’%Y-%m-%d’ 是截取后的日期格式。\nselect date_format(‘1997-10-04 22:23:00’,’%y %M %b %D %W %a %Y-%m-%d %H:%i:%s %r %T’);\n结果：97 October Oct 4th Saturday Sat 1997-10-04 22:23:00 10:23:00 PM 22:23:00\nsql-- get_date = &quot;2006-12-07&quot;\nSELECT count(*) FROM t_get_video_temp Where DATE_FORMAT(get_date, &#39;%Y-%m-%d&#39;)=&#39;2006-12-07&#39;; sqlSELECT count(*) FROM t_get_video_temp Where get_date like &#39;2006%-07%&#39;;\n1193. Monthly Transactions I\n\n11. Mysql中日期大小可以用min()取到最小日期\n12. where (字段) in (查询)1174. Immediate Food Delivery II\n对一张表的重复操作有奇效。先筛一次数据，然后对筛选结果进行汇总。\n13. 日期要用引号包裹。14. Round函数的使用round(值, 0) &#x3D;&gt; 整数\nround(值, 1) &#x3D;&gt; 一位小数\nround(值, 2) &#x3D;&gt; 两位小数\n15. Union的使用Union主要用于合并两个结果集. 简而言之就是在原先行的情况下往下追加行\n","slug":"SQL 查漏补缺","date":"2023-10-15T10:44:08.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"78bf35c97e41da6a2bdad05b63951aa3","title":"函数式编程","content":"1.概述Lambda是JDK8中的一个语法糖。可以对匿名内部类的写法进行简化。是函数式编程思想的体现。类型可以推导-&gt;省略类型方法可以推导-&gt;省略方法\n2.基本格式(参数列表) -&gt; 代码\n3. 实例之前在多线程的学习中提到过，线程Thread的创建方式比较知名的有三种：实现Thread、 new Thread(new Runnable())、实现Callable接口.在第二种方法: 实现Runnable接口时，我们可以用一个匿名内部类，来创建实现Runnable接口的对象。\njavaThread thread = new Thread(new Runnable() &#123;\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;匿名内部类&quot;);\n    &#125;\n&#125;)\nthread.start();通过Lambda，我们可以简化代码成：\njavanew Thread(()-&gt;System.out.println(&quot;匿名内部类&quot;)).start;","slug":"Lambda表达式","date":"2023-10-11T18:23:00.000Z","categories_index":"Java基础","tags_index":"Java基础,Java,Lambda表达式","author_index":"Kangwei Zhu"},{"id":"836018e6b061b33a02925aab024ae1c6","title":"测试基础回顾","content":"1. 主流测试技术1.1 功能测试\n\n\n\n\n\n\n\n\n验证程序的功能是否能满足需求\n1.2 自动化测试\n\n\n\n\n\n\n\n\n使用代码或工具代替手工，对项目进行测试\n1.3 接口测试\n\n\n\n\n\n\n\n\n测接口。\n1.4 性能测试\n\n\n\n\n\n\n\n\n模拟多人使用软件，查找服务器缺陷。\n2.测试分类2.1 按测试阶段划分\n\n\n\n\n\n\n\n\n单元、集成、系统、验收\n单元：针对源代码测试（开发自己做）\n集成：接口测试。针对模块之间访问进行测试。\n系统：对整个系统进行测试。（功能、兼容、文档等测试）\n验收：内测、公测。不同人群对项目提供反馈。\n2.2 按代码可见度划分2.2.1 黑盒测试属于系统测试\n\n源代码不可见\nUI可见\n\n2.2.2 灰盒测试属于接口测试（集成测试）\n\n部分源代码可见\n\n功能不可见（只有纯接口）\n\n\n2.2.3 白盒测试属于单元测试\n\n源代码完全可见\nUI不可见\n\n3. 质量模型\n\n\n\n\n\n\n\n\n质量模型用于衡量一个优秀软件的维度。\n\n功能性\n\n性能：每秒请求数 &lt;&#x3D; 服务器硬件是否满足\n\n兼容性：多平台。浏览器、操作系统、分辨率、网络、应用之间\n\n易用性：简洁、友好、流畅、美观\n\n可靠性：卡顿、服务器宕机、闪退\n\n安全：信息传输，存储。加密。\n\n可维护性\n\n可移植性\n\n\n4. 测试流程\n需求评审确保各部门需求理解一致\n计划编写测什么、谁来测、怎么测、\n用例设计验证项目是否符合需求的操作文档\n用例执行项目模块开发完成后，执行用例文档，实施测试\n缺陷管理对缺陷进行管理\n测试报告实施测试结果文档\n\n5. 测试用例\n\n\n\n\n\n\n\n\n用例：用户使用的案例。\n测试用例：为测试项目而设计的执行文档\n5.1 测试用例的作用\n防止漏测\n实施测试的标准\n\n5.2 用例设计编写格式八大要素：用例编号，用例标题，项目&#x2F;模块，优先级，前置条件，测试步骤，测试数据，预期结果\n\n用例编号: 项目_ 模块 _编号\n\n用例标题：预期结果（测试点）\n\n项目&#x2F;模块：所属项目或模块\n\n优先级：表示用例的重要程度或影响力。从p0到p4。最高为p0\n\n核心功能：用户、高频\n\n\n前置条件：要执行词条用力，有哪些前置操作\n\n测试登录：先要打开登录页面，才能。。。\n\n\n测试步骤：描述操作步骤\n\n测试数据：操作的数据，没有的话可以为空\n\n预期结果：期望达到的结果\n\n\ndemo:\n\n5.2.1 Excel下拉复制的同时使数字不会自增按住ctrl然后下拉\n6. 等价类划分法\n\n\n\n\n\n\n\n\n在所有的测试数据中，具有某种共同特种的数据集合进行划分。划分之后的结果分为两类：\n\n有效等价类：满足需求的数据集合\n需求：统计出生时性别为男孩的人数。则所有新生儿中男孩为有效\n\n\n无效等价类：不满足需求的数据结合\n上面例子中的女孩。\n\n\n\n6.1 Demo：验证账号的合法性\n需求：账号长度需要是6~ 10位自然数\n\n步骤：\n\n明确需求\n账号长度需要是6~ 10位自然数\n\n\n划分有效等价类\n有效：八位\n无效：三位、十二位\n\n\n提取数据，编写用例\n八位：12345678\n三位：123\n十二位：123456789012\n\n\n\n\n6.1.1 根据类型完善\n\n\n\n\n\n\n\n\n\n需求最多也就可以被分成：长度、类型、规则\n6.2 Demo：电话号码要求：\n\n区号：空或者是三位数字\n前缀码：非”0”且非”1”开头的三位数字\n后缀码：四位数字\n\n\n6.3 等价类适用场景需要有大量的数据测试输入，但是没法穷举测试的地方\n\n输入框\n下拉列表\n单选、复选框\n\n7. 边界值分析方法7.1  边界范围节点\n选择正好等于、刚好大于、刚好小于边界的值作为测试数据\n\n上点： 边界上的点（正好等于)\n离点： 距离上点距离最近的点（刚好大于、刚好小于)\n内点： 范围内的点（一般取中间的）\n\n\n这样算下来。最多7条。（两个商店，四个离点，一个内点）\n\n注意：内点需要两条用例（正反）\n\nDemo：等价类和边界值合一块写\n\n要求：账号长度需要是6到10位自然数（6和10也可以）\n\n\n从这个例子不难看出。其实等价类的分析：长度、类型、规则，其实结合了边界值之后，长度，规则这两点就交给边界值分析了。比如对要求账号是6到10位，那么有效等价就是自然数，无效等价就是非自然数。而原先哪些长度，规则，就由边界值进行判定。\n\n\n7.2 优化开内闭外：开区间选内点，闭区间选外点\n开区间：边界点没有等号   （如大于0小于10）\n闭区间：边界上的点有等号（如大于等于0小于等于10)\n那么可以看到上面的案例中，因为6和10时包含的，那么属于双闭，选外点。那么内点7和9就不需要了。数量优化到5点。\n8. 判定表\n\n\n\n\n\n\n\n\n很多场景，用例存在条件依赖关系。比如欠费就停机。这时候就无法单一地去测了。\n\n等价类以及边界值更加关注单个输入类条件的测试\n并未考虑输入条件之间的组合，输入条件和输出结果之间的依赖关系。\n\n判定表：以表格的形式表达 多条件逻辑判断 的工具\n\n组成：\n条件桩：列出问题中的所有条件。次序是无关紧要的\n动作桩：列出问题中可能采取的操作。操作的顺序同样无关紧要\n条件项：条件的取值\n操作：条件叠加后的结果\n\n\n\n\n\n假设有n个条件，每个条件取值有m个，全部组合就有m的n次方种规格。当然，绝大多数的情况下，条件的取值有2个\n\n像上图这样把表格整理出来后，每一列都是一个用例。\n\n判定表一般适用于条件少于4个的情况，如果条件多于4个，就要用正交表了。\n\n\n9. 业务覆盖测试9.1 流程图\n\n\n\n\n\n\n\n\n业务用例是根据流程图来梳理的\n开始和结尾用椭圆。\n中间用判断语句连接。菱形\n判断语句连接结果。\n\n9.2 ATM Demo\n\n\n\n其实就是把退出的场景都测一遍。然后流程通过的场景测一遍。\n\n10. 错误推荐法\n\n\n\n\n\n\n\n\n当项目测试用例都执行完毕，且bug修复完成，项目尚未上线的情况下，在这段时间里可以 通过经验推测系统可能出现的问题，列出问题的清单，分析问题可能的原因。\n\n时间紧、任务量大 -&gt; 根据已有经验找出易出错的模块重点测试。\n\n11. 缺陷\n\n\n\n\n\n\n\n\n软件在使用过程中存在的任何问题都叫软件的缺陷，简称bug。\n11.1 缺陷的判定标准\n少功能：软件未实现需求说明书中明确要求的功能\n功能错误：软件中出现了需求说明书中指明不应该出现的错误\n多功能： 软件实现的功能超出了需求说明书中指明的范围\n隐性功能错误： 软件未实现需求说明书中虽未明确指明，但应该实现的要求\n不易使用：软件难以理解，不易使用，运行缓慢，用户体验不好。\n\n11.2 缺陷产生的原因从需求到发布是一个线性的过程。其中一个环节出错，都会导致缺陷\n\n阶段1. 需求阶段\n需求描述不易理解，有歧义，错误\n\n阶段2. 设计阶段\n设计文档存在错误和缺陷\n\n阶段3. 编码阶段\n代码出现错误\n\n阶段4. 运行阶段\n软硬件系统本身故障导致软件缺陷\n\n\n11.3 缺陷的生命周期\n11.4 缺陷的核心内容\n缺陷标题\n缺陷预期结果\n缺陷产生的条件\n因缺陷得到的结果\n复现缺陷的过程\n缺陷的证据\n\n11.5 缺陷的提交要素\n11.6 软件缺陷类型\n功能错误\nUI错误\n兼容性\n数据\n易用性\n改进\n架构\n\n11.7 缺陷的跟踪流程\n11.8 缺陷模板\n","slug":"测试理论","date":"2023-10-08T16:36:00.000Z","categories_index":"软件测试","tags_index":"软件测试","author_index":"Kangwei Zhu"},{"id":"d6d38527940b56c092c8f8da1f15978f","title":"Web自动化测试快速入门(Java + Selenium 4)","content":"Selenium 快速入门1. Selenium官方文档\n\n\n\n\n\n\n\n\nhttps://www.selenium.dev/documentation/\n2. 第一个Selenium测试案例使用idea，新建maven项目，导入junit和selenium依赖。\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;\n         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;\n    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;\n\n    &lt;groupId&gt;com.anicaaz&lt;/groupId&gt;\n    &lt;artifactId&gt;Selenium-Learning&lt;/artifactId&gt;\n    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;\n\n    &lt;properties&gt;\n        &lt;maven.compiler.source&gt;11&lt;/maven.compiler.source&gt;\n        &lt;maven.compiler.target&gt;11&lt;/maven.compiler.target&gt;\n        &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt;\n    &lt;/properties&gt;\n\n    &lt;dependencies&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-java&lt;/artifactId&gt; &lt;!-- &lt;=左键点这里的selenium-Java --&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;!-- https://mvnrepository.com/artifact/org.junit.jupiter/junit-jupiter-api --&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.junit.jupiter&lt;/groupId&gt;\n            &lt;artifactId&gt;junit-jupiter-api&lt;/artifactId&gt;\n            &lt;version&gt;5.10.0&lt;/version&gt;\n            &lt;scope&gt;test&lt;/scope&gt;\n        &lt;/dependency&gt;\n\n    &lt;/dependencies&gt;\n&lt;/project&gt;网上不少教程说是要下载浏览器驱动，比如chrome就得下载chronium，firefox就得下载firefox驱动。在maven项目中这种就属于多此一举。左键点击被标签包裹的selenium-java。其实可以看到selenium-java-4.12.1.pom 已经帮我们配好了各种驱动。以下是部分。\nxml&lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-firefox-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-ie-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-remote-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n        &lt;dependency&gt;\n            &lt;groupId&gt;org.seleniumhq.selenium&lt;/groupId&gt;\n            &lt;artifactId&gt;selenium-safari-driver&lt;/artifactId&gt;\n            &lt;version&gt;4.12.1&lt;/version&gt;\n        &lt;/dependency&gt;\n\n\n\n\n\n\n\n\n第一个测试案例，测试title名称。\njavapackage scripts;\n\nimport org.junit.jupiter.api.Assertions;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FirstSeleniumTest &#123;\n\n    @Test\n    public void firstTest() &#123;\n        WebDriver driver = new ChromeDriver();//使用driver驱动，开启会话\n        driver.get(&quot;https://www.baidu.com&quot;);//导航到某网页\n        String title = driver.getTitle();//获取index.html的title\n        Assertions.assertEquals(title, &quot;百度一下，你就知道&quot;);//断言\n        driver.manage().timeouts().implicitlyWait(Duration.ofMillis(500));//等待500毫秒，可以用于等待网页资源加载。也可以单纯就是sleep.注意这里是官方推荐的隐式等待策略。\n        driver.close();//关闭session.\n    &#125;\n&#125;3. 元素定位方式\n\n\n\n\n\n\n\n\n在传统测试中，比如要对一个网页进行功能测试，在没有自动化测试工具协助的情况下，一搬我们的流程就是：\n\n找到要测试的元素\n对其进行测试\n\n在自动化测试中，其实也差不多。只不过我们要找的元素是在网页源码中找，而在不是传统的UI中找。\n\n找什么： 找属性、标签、层级、路径\n怎么找： 浏览器中左键你想找的UI，跳出的菜单里点检查。\n\n在Selenium中，元素定位方式，标准来讲，是以下八种\n但是现实中，只有手写xpath最稳定\n3.1 id （元素属性）id定位就是通过元素的id属性来定位元素。\nHTML规定id属性在整个Html文档中是唯一的\n使用id定位的前提是元素得有id属性。\n如果一个属性的id,会动态的修改，比如id后面多出来一串数字，这时候就得用xpath.\n具体怎么用，直接看源码。\n\n所有定位，都用这个findElement方法。不难看出，方法参数是一个By类型的对象。ide里写个By，然后ctrl+左键进去看一下：\n\n我们说的元素查找方式全在里面。看一下strucutre，是不是对上号了？\n\n粗略看了一眼，By类是一个抽象类，By的具体实现应该是静态内部类实现的。以后分析。\n找完了id，那还得接收他的对象吧。毕竟还需要对这些对象执行click，sendkeys等操作。我们用.var来看一下这个对象的名字是什么。\n结果发现是WebElement接口，点进去，把方法看明白就行。\n\n完整demo\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FindElementDemo &#123;\n    //通过\n    @Test\n    public void idTest() throws InterruptedException &#123;\n        //获取浏览器对象\n        WebDriver driver = new ChromeDriver();\n        //打开本地页面\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        //查找用户名元素\n        By by = By.id(&quot;userA&quot;);\n        WebElement username = driver.findElement(by);\n        //查找密码元素\n        WebElement password = driver.findElement(By.id(&quot;passwordA&quot;));\n        //用户名输入框，输入admin\n        username.sendKeys(&quot;admin&quot;);\n        //密码输入框，输入123456\n        password.sendKeys(&quot;123456&quot;);\n        //更直观地看见自动输入的流程\n        Thread.sleep(10000);\n        //关闭session\n        driver.quit();\n    &#125;\n&#125;链式写会更简洁。\n3.2 name （元素属性）name在html中可重复。\n使用前提是元素得有name属性。\njava    @Test\n    public void nameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        driver.findElement(By.name(&quot;userA&quot;)).sendKeys(&quot;admin&quot;);\n        driver.findElement(By.name(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.3 class_name （元素属性）和name、id方式几乎一致\n如果class有多个属性值，只能使用其中一个。\njava    @Test\n    public void classTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.className(&quot;telA&quot;)).sendKeys(&quot;18611111111&quot;);\n        /*driver.findElement(By.className(&quot;emailA&quot;)).sendKeys(&quot;anicaazhu@gmail.com&quot;);*/\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.4 tag_name （标签名称）和class的缺陷是差不多的。一个html里可能有重名。而且几乎必然有重名标签。这种情况下，我们永远只能找到第一个tag。\n当然还是有办法可以找到第二个相同类型的tag的。driver.findElements(By by)会返回一个list。list中装了html中，所有与查找的类型相同的标签。list.get(int index)就能获取到具体的标签，从上往下，通常是。\njava    @Test\n    public void tagNameTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.tagName(&quot;input&quot;)).sendKeys(&quot;TagName Test&quot;);\n        driver.findElements(By.tagName(&quot;input&quot;)).get(1).sendKeys(&quot;Second Input Tag Test&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.5 link_text （超链接）文本必须为全部匹配\n必须只能定位a标签\nhtml&lt;a&gt;aaaa&lt;/a&gt;匹配的就是这个”aaaa’\njava    @Test\n    public void linkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.6 partial_link_text (超链接，模糊查找)和link_text唯一区别就是可以模糊查。\n模糊查并不是出现过相同字符就可以。必须是缺少才行。这么说可能有点抽象，举个例子：\n\n\n\n\n\n\n\n\n\n我们要找的linktext是 “aaaaa”.\n那么。partialLinkText可以为“aaaaa”(完全一致)，也可以为”a”, “aaa”, “aa”, “aaaa”. 但是，不可以是“aaaaaa”或”aab”这种。\njava    @Test\n    public void partialLinkTextTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(this.url);\n        //driver.findElement(By.linkText(&quot;访问 新浪 网站&quot;)).click();//完全一致是可以的\n        //driver.findElement(By.partialLinkText(&quot;访问 新浪网站&quot;)).click();//不可以\n        driver.findElement(By.partialLinkText(&quot;访问&quot;)).click();//可以\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.7 XPath （基于元素路径）之所以用XPath和CSS，是因为万一前六种情况都不能用，就白瞎了。\n比如这种情况\n&lt;input type=&quot;submit&quot; value=&quot;提交&quot; /&gt;\n没有id，没有name，没有class。\ntag吧，万一他不是该页面第一次出现的，也不好找。\nlink_text和partiall_link_text，专门给a标签用的，input不对口。\n所以只能能用XPath和CSS方法来定位。\n\n\n\n\n\n\n\n\n\nXPath是 XML Path的简称。它是一门在XML文档中查找元素信息的语言。\nHTML可以看作是XML的一种。所以Selenium用户可以使用这种强大的语言的Web应用中定位元素。\n各种文件的作用：\n\nXML的重点在于数据的存储和传递。常用于软件配置。\nHTML显示元素\nCSS控制显示元素的样式\n\nXPath偷懒，不手写：\n​\t\n3.7.1 路径定位：绝对路径\n\n\n\n\n\n\n\n\n必须从html开始。格式：/html/.../...\n3.7.2 路径定位：相对路径\n\n\n\n\n\n\n\n\n必须以//元素名开头\n不知道元素名，用*代替\n开发时建议相对路径：如果层级变化，绝对路径大概率会失效。\njava    @Test\n    public void xPathTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        //1.使用绝对路径获取username输入框\n        String absPath = &quot;/html/body/form/div/fieldset/p[1]/input&quot;;\n        driver.findElement(By.xpath(absPath)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        //2.使用相对路径获取username输入框\n        String relativePath = &quot;//p[@id=&#39;p1&#39;]/input&quot;;//\n       //p[@id=&quot;p1&quot;]/input  这样可以    //*[@id=&quot;userA&quot;]也可以  注意java“”中的“”要用\\\\隔开。即\\&quot;p1\\&quot;，当然也可以用单引号代替\n        driver.findElement(By.xpath(relativePath)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.7.3 XPath扩展\n\n\n\n\n\n\n\n\n对于被标签夹着的文本。可以用//*[text()=&#39;字符&#39;]来定位\n对于属性中含有xxx元素，可以用&#x2F;&#x2F;*[contains(@attribute, &#39;属性名&#39;)]. 属性名可以模糊。\n对于属性以xxx开头的元素，可以用//*[start-with(@属性类型, &#39;属性名&#39;)]. 可以模糊。\n3.8 CSS （元素选择器）3.8.1 id选择器根据id属性名来选择\n格式：#属性名\n3.8.2 class选择器根据class属性名来选择\n格式：.属性名\n3.8.3 元素选择器根据元素的标签名称来选择\n格式：标签名\n3.8.4 属性选择器格式[属性&#x3D;‘属性名’] \ne.g. [id&#x3D;’passwordA’]\n3.8.5 层级选择器&gt;找直接子集，只能找下一级\n空格找后代\njava    @Test\n    public void cssSelectorTest() throws InterruptedException &#123;\n        WebDriver driver = new ChromeDriver();\n        driver.get(url);\n        driver.findElement(By.cssSelector(&quot;#userA&quot;)).sendKeys(&quot;admin&quot;);//通过id选择器，定位用户名，输入admin\n        driver.findElement(By.cssSelector(&quot;[id=&#39;passwordA&#39;]&quot;)).sendKeys(&quot;123456&quot;);//通过属性选择器，定位密码框，输入123456\n        driver.findElement(By.cssSelector(&quot;.telA&quot;)).sendKeys(&quot;110&quot;);//通过class选择器，定位手机号，输入110\n        System.out.println(driver.findElement(By.cssSelector(&quot;span&quot;)).getText());//定位span标签，获取文本值\n        driver.findElement(By.cssSelector(&quot;p&gt;input[type=&#39;emailA&#39;]&quot;)).sendKeys(&quot;123@qq.com&quot;);//通过层级标签，定位邮箱，输入123@qq.com\n        Thread.sleep(1000);\n        driver.quit();\n    &#125;3.8.6 CSS扩展input[type^&#x3D;’p’] 以p开头的元素\ninput[type$&#x3D;’d’] 以d结尾的元素\ninput[type*&#x3D;’w’] 包含w的元素\n3.9 RelativeLocators3.9.1 toLeftOf3.9.2 toRightOf3.9.3 near3.9.4 toAbove3.9.5 toBelow4. 元素操作4.1 元素操作常用方法 click( ) 单击元素\n clear() 清除文本\nsend_key(value) 输入文本\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class emulateBrowserApi &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void elementOperations() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        WebElement userA = webDriver.findElement(By.id(&quot;userA&quot;));\n        userA.sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.id(&quot;passwordA&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;telA\\&quot;]&quot;)).sendKeys(&quot;1861111111111&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[4]/input&quot;)).sendKeys(&quot;123@qq.com&quot;);\n        Thread.sleep(1000);\n        userA.clear();\n        Thread.sleep(1000);\n        userA.sendKeys(&quot;18600000000&quot;);\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;zc\\&quot;]/fieldset/button&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;文件上传案例：\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class FileUploadDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).click();//这样写是错误的\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[7]&quot;)).sendKeys(&quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n4.2 操作浏览器常用方法Selenium 4.0操作浏览器API变了。\ntxt//https://www.selenium.dev/documentation/webdriver/interactions/windowsjavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.*;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class BrowserOperations &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testOps() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url);\n        //https://www.selenium.dev/documentation/webdriver/interactions/windows\n        WebDriver.Window window = webDriver.manage().window();\n        window.maximize();//最大化窗口\n        Thread.sleep(1000);\n        window.setSize(new Dimension(300, 400));\n        Thread.sleep(1000);\n        window.setPosition(new Point(320, 450));\n        Thread.sleep(1000);\n        window.fullscreen();\n        Thread.sleep(1000);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.navigate().back();\n        Thread.sleep(1000);\n        webDriver.navigate().forward();\n        webDriver.navigate().refresh();\n        webDriver.close();\n    &#125;\n&#125;注意，close永远是关闭主窗口。\ntxt    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(this.url2);\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;user\\&quot;]&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(1000);\n        System.out.println(&quot;关闭主窗口之前的标题&quot; +webDriver.getTitle());\n        webDriver.navigate().refresh();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();\n        Thread.sleep(1000);\n        webDriver.close();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;4.3 获取元素信息方法均来自于WebElement接口的对象。均以getXxx()开头。\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Dimension;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ElementInfoDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        //1).获取用户名输入框的大小\n        Dimension size = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).getSize();\n        System.out.println(&quot;Size: &quot; + size.toString());\n        //2).获取页面上第一个超链接的文本内容\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[6]/a&quot;));\n        String text = element.getText();\n        System.out.println(&quot;超链接文本: &quot; + text);\n        //3).获取页面上第一个超链接的地址\n        String href = element.getAttribute(&quot;href&quot;);\n        System.out.println(&quot;超链接地址: &quot; + href);\n        //4).判断页面中的span标签是否可见\n        WebElement span = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[5]/span&quot;));\n        boolean displayed = span.isDisplayed();\n        System.out.println(displayed ? &quot;可见&quot; : &quot;不可见&quot;);\n        //5).判断页面中取消按钮是否可用\n        boolean enabled = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[5]&quot;)).isEnabled();\n        System.out.println(enabled ? &quot;可用&quot; : &quot;不可用&quot;);\n        //6).判断页面中&#39;旅游&#39;对应的复选框是否为选中的状态\n        boolean selected = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[3]&quot;)).isSelected();\n        System.out.println(selected ? &quot;选中&quot; : &quot;未选中&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n5. 鼠标和键盘操作5.1 鼠标操作\n\n\n\n\n\n\n\n\n鼠标操作官方文档： https://www.selenium.dev/documentation/webdriver/actions_api/mouse/\nActions对象的创建需要传入webdriver。\n通过调用Actions对象方法，来编写鼠标操作\n并用perform()来执行操作。\njavapackage scripts;\n\nimport org.checkerframework.checker.units.qual.A;\nimport org.checkerframework.checker.units.qual.C;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.interactions.Actions;\n\npublic class MouseDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement element = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        Actions actions = new Actions(webDriver).contextClick(element);//右键点击文本\n        actions.perform();//执行该动作\n\n        element.sendKeys(&quot;admin&quot;);\n        Actions actions2 = new Actions(webDriver).doubleClick(element);\n        actions2.perform();\n\n        WebElement element1 = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/button&quot;));\n        Actions actions3 = new Actions(webDriver).moveToElement(element1);//悬停\n        actions3.perform();\n        Thread.sleep(10000);\n        webDriver.quit();\n    &#125;\n&#125;拖拽操作demo：\n将red区块覆盖掉green区块。\ntxt    @Test\n    public void testDragAndDrop() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url2);\n        WebElement red = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div1\\&quot;]&quot;));\n        WebElement green = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;div2\\&quot;]&quot;));\n        Actions actions = new Actions(webDriver);\n        actions.dragAndDrop(red, green);\n        actions.perform();\n        Thread.sleep(1000);\n        webDriver.quit();\n    &#125;上面demo是拖拽到指定目标的位置。如果想要单目标拖拽，可以使用\nactions.dragAndDropBy(Webelement element, int xOffset, int yOffset)来实现拖拽。注意，在常见的图形api中，(0,0)这个坐标指的是屏幕的左上角。\n拖拽的实现，其实可以细分成以下动作：\n\n鼠标悬停到指定区，\n按住鼠标左键\n将鼠标悬停到目标区块\n松开鼠标\n\n5.2 键盘操作Selenium的键盘操作全部封装在Keys这个enum类中。\n\n通过webDriver.sendKeys(Keys.XXX)来调用\nDemo:\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.security.Key;\n\npublic class KeyBoardDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void testCopyAndPaste() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        WebElement usernameInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;));\n        usernameInput.sendKeys(&quot;admin1&quot;);//输入admin1\n        usernameInput.sendKeys(Keys.BACK_SPACE);//删除1\n        usernameInput.sendKeys(Keys.CONTROL, &quot;a&quot;);//全选\n        usernameInput.sendKeys(Keys.CONTROL, &quot;c&quot;);//复制\n        WebElement passwordInput = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;));//找到密码框\n        passwordInput.sendKeys(Keys.CONTROL, &quot;v&quot;);//黏贴\n        Thread.sleep(1000);\n        webDriver.close();\n    &#125;\n&#125;6.元素等待\n\n\n\n\n\n\n\n\n可能有些环境（网络、本地、插件原因）浏览器加载速度比较慢。就会出现找不到元素的情况。从而导致脚本抛出异常\n举个例子，往输入框里填写字符串的时候，可能浏览器还没加载出网页，那脚本自然也就找不到input元素了。\n为了解决这个问题，我们如果捕获到异常，就进入等待。等网页加载出来，再试试。\n具体一点，就是元素第一次未找到时，元素的等待就会被激活，如果在设置的有效时常内找到元素，则继续执行代码。如果超出设置的时常后仍未找到元素，则抛出异常。\n6.1显示等待\n\n\n\n\n\n\n\n\n定位指定元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该 元素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出超 时异常 TimeoutException 。\n只针对单个元素有效\n官方文档：https://www.selenium.dev/documentation/webdriver/waits/#explicit-waits\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class ExplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ZERO.withSeconds(10));\n        WebElement element = wait.until(d -&gt; d.findElement(By.id(&quot;userAA&quot;)));//故意写错的\n        element.sendKeys(&quot;admin&quot;);\n        webDriver.quit();\n    &#125;\n&#125;\n\n这里涉及到函数式变成。先知道这个d就是webDriver就可以。这个demo主要就是判断存不存在，存在就sendkey，不存在直接报错了。\n因为我们用的是webDriver，所以wait的实现类就是这个WebDriverWait。可以看到的确实会报timeoutException。\n\n6.2隐式等待\n\n\n\n\n\n\n\n\n定位元素时，如果能定位到元素则直接返回该元素，不触发等待； 如果不能定位到该元 素，则间隔一段时间后再去定位元素； 如果在达到最大时长时还没有找到指定元素，则抛出元素 不存在的异常 NoSuchElementException 。\n隐式等待对所有元素都有效\ntxtpackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.util.concurrent.TimeUnit;\n\npublic class ImplicitWaitDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);\n        webDriver.findElement(By.xpath(&quot;aaa&quot;));\n        webDriver.quit();\n    &#125;\n&#125;\n可以把webDriver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);注释掉，对比一下，是不是真的等了10秒钟。\nimplicitlyWait这个参数有两种。一种是Duration对象，一种是(long time, TimeUnit timeunit)。后者，也就是demo中的写法(Selenium 3)已经是deprecated的了。\n7. 下拉选择框html下拉框是&lt;select&gt;元素\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class SelectDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select/option[2]&quot;)).click();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n\n&#125;\n7.1 Select类如果每次都用cssSelector来对select标签进行定位的话，太麻烦。Selenium为select标签定位提供了Select类封装，直接操作Select标签。\nselect类创建时需要将select标签的webelement作为参数传进去。\n具体看注释。写的很清楚了\njava    @Test\n    public void testSelectClass() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        WebElement selectTag = webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[11]/select&quot;));\n        Select select = new Select(selectTag);\n        Thread.sleep(5000);\n        select.selectByIndex(1);//从0开始\n        Thread.sleep(5000);\n        select.selectByValue(&quot;gz&quot;);//标签属性中的value\n        Thread.sleep(5000);\n        select.selectByVisibleText(&quot;A重庆&quot;);//开合标签夹着的文本\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;8. 弹出框常用三种：\n\nalert 警告框\n\nconfirm 确认框\n\nprompt 提示框\n\n\n处理方式都一样。\n\n如果点击警告框后不处理，那么后面的操作都无法执行。\n\n处理方法：\n\n切换到对话框\nalert.text() &#x2F; alert.dismiss() &#x2F; alert.accept()\n\n\n\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.Alert;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.openqa.selenium.support.ui.ExpectedCondition;\nimport org.openqa.selenium.support.ui.ExpectedConditions;\nimport org.openqa.selenium.support.ui.Wait;\nimport org.openqa.selenium.support.ui.WebDriverWait;\n\nimport java.time.Duration;\n\npublic class PopUpDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册A.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        //这四行是公式\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(url);\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/form/input[6]&quot;)).click();//点击\n        Thread.sleep(5000);\n        Wait&lt;WebDriver&gt; wait = new WebDriverWait(webDriver, Duration.ofSeconds(10));\n        wait.until(ExpectedConditions.alertIsPresent());//等代窗口跳出来 这里可以直接用Alert接受，那么下面一行就不用写了。同理，要写下行，其实这行就不用写了。这边单纯为了把两个方式都写一下。\n        Alert alert = webDriver.switchTo().alert();//捕获alert\n        System.out.println(alert.getText());\n        alert.accept();\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;\n9. 滚动条操作\n\n\n\n\n\n\n\n\n滚动条菜单使用场景\n\n在HTML页面中，由于前端技术框架的原因，页面元素为动态显示，元素根据滚动条的下拉而被加载 \n页面注册同意条款，需要滚动条到最底层，才能点击同意\n\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.JavascriptException;\nimport org.openqa.selenium.JavascriptExecutor;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class ScrollBarDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.selenium.dev/documentation/legacy/selenium_2/faq/#q-how-do-i-execute-javascript-directly&quot;);\n        JavascriptExecutor javascriptExecutor = (JavascriptExecutor) webDriver;\n        Thread.sleep(5000);\n        javascriptExecutor.executeScript(&quot;window.scrollTo(0,10000)&quot;);//0是x，10000\n        Thread.sleep(5000);\n        webDriver.close();\n    &#125;\n&#125;10. Frame切换\n\n\n\n\n\n\n\n\n官网文档： https://www.selenium.dev/documentation/webdriver/interactions/frames/\n多种办法。swtich完了记得switch回来。\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\n\npublic class FrameDemo &#123;\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() throws InterruptedException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n\n        WebDriver myframe1 = webDriver.switchTo().frame(&quot;myframe1&quot;);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin&quot;);\n        Thread.sleep(5000);\n        myframe1.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[2]/input&quot;)).sendKeys(&quot;123456&quot;);\n        Thread.sleep(5000);\n        webDriver.switchTo().defaultContent();\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[1]/input&quot;)).sendKeys(&quot;admin1&quot;);//如果不swithc回default。那就一直卡在frame里了,会往frame里定位到的相同元素追加\n        Thread.sleep(5000);\n        myframe1.quit();\n    &#125;\n&#125;\n11. 多窗口切换三个api：\n\nwebDriver.switch().window(String handleName) 切换到指定句柄名的窗口\n之所以要切换，是因为如果切换到了新的窗口，想要操作新窗口的元素的话，就需要切换。有点类似上面的frame切换。\n\n\nwebDriver.getWindowHandle(); 返回字符串.   获取当前窗口句柄\nwebDriver.getWindowHandles(); 返回存储字符串的Set. 获取所有窗口句柄\n\n代码注释很清楚了。\njavapackage scripts;\n\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.time.Duration;\nimport java.util.Objects;\nimport java.util.Set;\n\npublic class WindowHandleDemo &#123;\n\n    private String url = &quot;C:\\\\Users\\\\18795\\\\IdeaProjects\\\\Selenium-Learning\\\\src\\\\test\\\\java\\\\resources\\\\注册实例.html&quot;;\n\n    @Test\n    public void test() &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(url);\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.manage().window().maximize();\n\n        //获取所有窗口句柄\n        Set&lt;String&gt; windowHandles = webDriver.getWindowHandles();\n        for (String s : windowHandles) &#123;\n            System.out.println(s);\n        &#125;\n        String defaultHandle = webDriver.getWindowHandle();\n        System.out.println(defaultHandle);// 两次结果应该一致，因为只有初始网页打开. 所以我们拿到了初始窗口的句柄\n\n\n        webDriver.findElement(By.xpath(&quot;/html/body/form/div/fieldset/p[8]/a&quot;)).click();//点击超链接，打开新窗口\n        windowHandles = webDriver.getWindowHandles();//重新获取所有句柄\n        System.out.println(webDriver.getWindowHandle());//如果不进行切换的话，就算打开了新的窗口，当前窗口句柄依然是最初的\n        //判断是否为新开窗口\n        for (String s : windowHandles) &#123;\n            System.out.println(s);//此时会发现，除了3条主窗口句柄，还多了一个新的句柄\n            //如果句柄不是主窗口，则切换\n            if (!Objects.equals(defaultHandle, s)) &#123;\n                webDriver.switchTo().window(s);\n            &#125;\n        &#125;\n        System.out.println(webDriver.getWindowHandle());//现在就切换到新窗口了\n        webDriver.close();//先关掉新窗口\n        webDriver.switchTo().window(defaultHandle);//回到初始窗口。\n        webDriver.close();//关掉初始窗口。如果不先关新开窗口的话，新的窗口其实就一直不会关。可以注释掉代码看下\n    &#125;\n&#125;12.截屏txtpackage scripts;\n\nimport org.apache.commons.io.FileUtils;\nimport org.junit.jupiter.api.Test;\nimport org.openqa.selenium.OutputType;\nimport org.openqa.selenium.TakesScreenshot;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\nimport java.io.File;\nimport java.io.IOException;\n\npublic class ScreenshotDemo &#123;\n\n    @Test\n    public void test() throws InterruptedException, IOException &#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.get(&quot;https://www.google.com&quot;);\n        TakesScreenshot takesScreenshot = (TakesScreenshot) webDriver;\n        File screenshot = takesScreenshot.getScreenshotAs(OutputType.FILE);\n        //mvn 导入 common io的FileUtil\n        FileUtils.copyFile(screenshot, new File(&quot;./resources/image.png&quot;));\n    &#125;\n&#125;Selenium入门完结。\n\nSelenium 进阶1. Selenium IDE谷歌扩展里搜Selenium， 安装，打开。\n\n录制一个test。保存，自动执行。这样不用写一行代码，也能做同样的事情。\n除了Selenium之外， 还有一个交Katalon Recorder， 也是做同样的事情。 \n然后也可以将录制的test，导出成使用各种语言 + Selenium框架的成品代码。\n好处是成本比较低，但是代码的可读性很差。\n2. Selenium细节2.1 Grid &amp; RC &amp; WebDriver2.1.1. GridGrid就是写好了测试脚本，在各个环境下（系统&amp;浏览器）中执行。\n\n2.1.2 RCRC主要用于JS注入，是一个boarding lib, 可以被看成是远古版的webDriver. 方法都很简单。启动server, 运行你的代码，把代码通过js,注入进浏览器。\n缺陷：有些浏览器不支持 JS注入。\n2.1.3 WebDriverWebDriver各个浏览器不同。原生操作。\n2.2 Selenium涵盖范围Web  - WebDriver\nDesktop based - WinAppDriver\nMobile App - Appnium\n2.3 Selenium 版本迭代2.3.1 Selenium 1IDE + RC + Grid\nIDE提供录制， RC提供JS注入来控制浏览器操作， Grid负责自动执行。\n2.3.2 Selenium 2\n在IDE和RC的基础上新增了WebDriver。减少了很多原本的RC架构。提供多语言支持。WebDriver由浏览器官方提供，Selenium将使用各种语言写好的测试脚本转换成json，通过JSON WIRE协议， 发送给浏览器官方提供的WebDriver.\n2.3.3 Selenium 3没有RC， WebDriver + IDE + Grid 3。\n2.3.4 Selenium 4\n不用JSON Wire Protocol了， 直接通信。重做Grid。W3C兼容。稳定。\n3. Q &amp; A3.0 在Linux环境下如何进行Selenium测试？\n\n\n\n\n\n\n\n\n不同于 Windows , 在 Linux 下需要制定定 WebDriver 的路径或环境变量。或者，也可以使用 WebDriverManager 包，对指定的浏览器进行setup()，来执行测试用例。\njavaWebDriverManager.chromedriver().setup();\n3.1 如何使用Selenium获取窗口的标题。\n使用 xxxDriver.getTitle();\njavapackage Questions;\n\nimport io.github.bonigarcia.wdm.WebDriverManager;\nimport org.openqa.selenium.chrome.ChromeDriver;\n\npublic class HowToGetTitle &#123;\n\n    public static void main(String[] args) &#123;\n        WebDriverManager.chromedriver().setup();\n        ChromeDriver chromeDriver = new ChromeDriver();\n        chromeDriver.get(&quot;http://www.baidu.com&quot;);\n        String title = chromeDriver.getTitle();\n        System.out.println(title);\n        chromeDriver.quit();\n    &#125;\n&#125;\n3.2 xxxDriver.quit()和close()的区别？\nquit() 是关闭所有窗口，而 close() 是关闭单一窗口。\n3.3 为什么要使用 TestNG\n\n\n\n\n\n\n\n\n多个test case情况下，在selenium中是看不出具体哪个test case fail的， 或者说不够直观。TestNG 可以很好的 管理，报告test cases.\n3.4  Maven 是什么\n\n\n\n\n\n\n\n\nBuild Tool &amp; Dependency Manager\n​\t\t\n3.5 Jenkins 是什么\n\n\n\n\n\n\n\n\n一个 UI, 用于执行 test case, 同时查看 report.\n3.6 WebDriver结构\n","slug":"Selenium学习","date":"2023-09-27T13:19:00.000Z","categories_index":"软件测试","tags_index":"Selenium","author_index":"Kangwei Zhu"},{"id":"c4b37ef49fa66d2e8dcfeb1e2c791dc4","title":"速通TestNG","content":"TestNG1. TestNG官方文档：\n\n\n\n\n\n\n\n\nhttps://testng.org/doc/documentation-main.html\n2. 什么是TestNG？\n\n\n\n\n\n\n\n\nTestNG 是一个测试框架。用于unit（单元测试）、integration（集成测试）、end to end（端到端测试）以及function testing（功能测试.\n\nNG: next generation\n\n目前学习TestNG主要还是为了以下几点：\n\n批量进行测试用例管理和调度执行\n生成报告。\n结合PO设计模式进行Web自动化测试\n\n\n博客： https://bbs.huaweicloud.com/blogs/300746\n\n\n3. 第一个Selenium + TestNG测试案例\n\n\n\n\n\n\n\n\n打开谷歌。在搜索栏填入信息，按下enter。\n其实写法和JUnit是完全一样的。\njavaimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FirstTestNGDemo &#123;\n\n    @Test\n    public void firstTest() throws InterruptedException&#123;\n        WebDriver webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();;\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        Thread.sleep(5000);\n        webDriver.quit();\n    &#125;\n&#125;3.1 默认测试报告\n\n然后就能看到这个文件夹。里面这个emailable-report.html就是报告。\n\n小问题：WebDriver成员变量我们的测试类不可能永远只写一个方法。当存在多个方法时，我们想高效地利用WebDriver，比如保存WebDriver的状态，这样各个method就能衔接起来。\n举个例子:\n我们要测试登录qq账号以及发消息给好友。那第一个method就是登录。如果没有全局变量，那在登录里我们就要创建WebDriver对象，给url。登录method写完了，当写发消息时，我们得重新创建对象，给对应的url。很麻烦。有人说为什么不把两个方法和在一起，那样就太乱了。一个类不可能永远只写一个代码，这时候就需要将WebDriver设为成员变量。当你登录成功，那WebDriver就是跳转到好友列表时候的状态。这样就不用重新创WebDriver了\n\n\n\n\n\n\n\n\n\n当然这是当前阶段的小问题。之后不可能这么些，因为这样还是很乱，封装的力度不够。\n4. TestNG 常用注解\n\n\n\n\n\n\n\n\n常用after&#x2F;before Suite、class。after&#x2F;before Test用的都算少了\n下面有这么多，其实都大差不差。\n@Before一般用于测试环境准备\n@After一般用于测试环境清理\n那么，我们想，当我们进行测试的时候，打开浏览器这个动作，其实跟测试内容的关系不是很大，是不是就是测试环境的准备？因此，我们可以用@BeforeClass，将其封装起来。\ntxt...\n\nprivate WebDriver webDriver;\n@BeforeClass\npublic void openBrowser() &#123;\n    //窗口、等待...etc..\n    webDriver.getUrl();\n&#125;@Testjavaimport org.openqa.selenium.By;\nimport org.openqa.selenium.Keys;\nimport org.openqa.selenium.WebDriver;\nimport org.openqa.selenium.WebElement;\nimport org.openqa.selenium.chrome.ChromeDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\nimport java.time.Duration;\n\npublic class FindWebsite &#123;\n    private WebDriver webDriver;\n\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = new ChromeDriver();\n        webDriver.manage().window().maximize();\n        webDriver.manage().timeouts().implicitlyWait(Duration.ofSeconds(10));\n    &#125;\n\n    //搜索www.anicaaz.com, 并判断第一条结果是否为“Kangwei Zhu&#39;s Blog: 首页”\n    @Test (priority = 1)\n    public void searchAnicaa() throws InterruptedException &#123;\n        webDriver.get(&quot;https://www.google.com&quot;);\n        webDriver.findElement(By.name(&quot;q&quot;)).sendKeys(&quot;www.anicaaz.com&quot;, Keys.ENTER);\n        System.out.println(webDriver.getTitle());\n        WebElement element = webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;));\n        String text = element.getText();\n        Assert.assertEquals(text, &quot;Kangwei Zhu&#39;s Blog: 首页&quot;);\n    &#125;\n\n    //跳转到www.anicaaz.com\n    @Test (priority = 2)\n    public void goToWebsite() throws InterruptedException &#123;\n        System.out.println(webDriver.getCurrentUrl());\n        webDriver.findElement(By.xpath(&quot;//*[@id=\\&quot;rso\\&quot;]/div[1]/div/div/div[1]/div/div/span/a/h3&quot;)).click();\n    &#125;\n\n    @AfterClass\n    public void quitBrowser() &#123;\n        webDriver.close();\n    &#125;\n&#125;在这个demo中，我们有两个连续的方法。搜索某网站时，肯定是先输入搜索内容，然后在从搜索结果里点击内容。但是，由于抢占问题，搜索结果这个步骤可能会优先执行，这样永远都是报错。因此，我们可以设置优先级。优先级默认值为0。优先级可以作用在类上，也可以作用在方法上。\n如果你的测试不仅仅只是测试能否访问网页，可能还有别的目的的话，记得用Assert。因为可能网页跑通了，testng就认为你通过测试了，但是你的功能其实是有问题的。\n此外，涉及到网页跳转的场景时，要注意别忘了隐式&#x2F;显示等待。因为网页加载需要时间。有时候可能脚本执行得比加载速度快，从而导致找不到元素。\n@BeforeMethod每个测试方法之前需要执行\n@AfterMethod每个测试方法之后需要执行\n@BeforeClass在当前类的第一个测试方法调用之前执行\n@AfterClass在当前类的最后一个测试方法调用之后执行\n@BeforeTest在当前类的第一个测试方法调用之前执行\n@AfterTest在测试之后需要执行的\n@BeforeSuite在测试之前需要执行的\n@AfterSuite测试套件在执行之后需要执行的\n第二个demo：\nclass1: 测试能否登录功能（这里选择谷歌账号）。\nclass2： 测试能否获取个人信息。\n在这里，如果没有登录。是拿不到个人信息的。因为class2的运行会一直卡在登录页面（class2的webDriver.get()内参数是登录之后的主页url）。\n要解决这个问题，就需要将class1中的WebDriver设为public static变量，方便调用。但是问题来了。你执行class2的时候，class1不可能一起执行啊。\njavaclass1：\n    private static WebDrvier webDriver;\n\nclass2:\n    private WebDriver webDriver;\n    @BeforeClass\n    public void openBrowser() &#123;\n        webDriver = class1.webDriver;\n    &#125;\n    \n    ..\n因此WebDriver就变成了空指针。这时候，就需要用到suite来管理这些类了。\n在TestNG中，最好一个类管理一个测试用例(具体还是看测试用例有多少），所有类（测试用例），则用suite管理。下面5.1.2会写道。\n5. TestNG XML文件1.1 TestNG XML文件的作用XML是用来写配置的，TestNG的xml也不例外。 \n在我们之前写过的所有demo中，每个测试类，大抵都只有一两个测试方法，我们只需要手动执行它。\n但是，在项目中，我们通常会有几百上千个类和方法，这种情况下，我们如何去执行，执行哪些，以什么顺序去执行这些测试方法，就成了问题。\n通过编写TestNG XML 文件，我们就可以很好的解决这个问题。\n1.1.1 安装TestNG插件idea -&gt; plugin -&gt; 搜索create testng xml\n1.2 编写TestNG XMLxml名字任意，xml文件数量任意。但是通常命名为testng.xml\nxml得放在resources里面\n\n\n\n\n\n\n\n\n\nTestng管理层级：\nsuite-&gt;test-&gt;class-&gt;method\n\ntestng.xml骨架\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n\n&lt;suite&gt;\n    &lt;test&gt;\n        &lt;classes&gt;\n            &lt;class&gt;\n                &lt;methods&gt;\n                    \n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;当然，手写很麻烦，可以直接通过testng插件生成。\n\n\n1.3 XML DEMO改造一下findWebsite，创建两个类。一个findWebiste，查找并进入www.anicaaz.com.另一个类findBlog，点击博客第一条。\nFindWebsite改动\n\njavaimport org.openqa.selenium.By;\nimport org.openqa.selenium.WebDriver;\nimport org.testng.Assert;\nimport org.testng.annotations.AfterClass;\nimport org.testng.annotations.BeforeClass;\nimport org.testng.annotations.Test;\n\npublic class FindBlog &#123;\n\n    private WebDriver webDriver;\n\n\n    @BeforeClass\n    public void setWebDriver() &#123;\n        webDriver = FindWebsite.webDriver;\n    &#125;\n\n    @Test\n    public void findBlog() &#123;\n        webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div[1]/div/div[2]/a/h1&quot;)).click();\n        String text = webDriver.findElement(By.xpath(&quot;/html/body/div/div[1]/div[2]/div[4]/div/div[1]/div/h1&quot;)).getText();\n        Assert.assertEquals(text, &quot;速通TestNG&quot;);\n    &#125;\n\n    @AfterClass\n    public void closeWebDriver() &#123;\n        webDriver.close();\n    &#125;\n&#125;xml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;!DOCTYPE suite SYSTEM &quot;http://testng.org/testng-1.0.dtd&quot;&gt;\n&lt;suite name=&quot;All Test Suite&quot;&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找网站&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindWebsite&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;searchAnicaa&quot;/&gt;\n                    &lt;include name=&quot;goToWebsite&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n    &lt;test verbose=&quot;2&quot; preserve-order=&quot;true&quot;\n          name=&quot;查找博客首页第一篇博客&quot;&gt;\n        &lt;classes&gt;\n            &lt;class name=&quot;FindBlog&quot;&gt;\n                &lt;methods&gt;\n                    &lt;include name=&quot;findBlog&quot;/&gt;\n                &lt;/methods&gt;\n            &lt;/class&gt;\n        &lt;/classes&gt;\n    &lt;/test&gt;\n&lt;/suite&gt;\n把Assert内容随便乱改点，就可以看到成功的报错了。\n\n6. PO模式与TestNG其实就是把页面当成一个对象来看。一个类，对应一个页面。\nPO： Page Object\n抽象对象：\n\n属性： url 元素（元素定位表达式）\n方法： 业务流程操作。\n\n高内聚: 页面属性放一块\n低耦合：不同页面通过webDriver来传递\n","slug":"TestNG学习","date":"2023-09-27T13:19:00.000Z","categories_index":"软件测试","tags_index":"TestNG","author_index":"Kangwei Zhu"},{"id":"9d46642f1b3ee040f345622df45965b4","title":"ArchLinux下GIT的配置","content":"1.换新设备时，拉取github&#x2F;gitee项目\n生成ssh key\n\nbashssh-keygen -t ed25519 -C &quot;anicaazhu@gmail.com&quot;\n复制该public key\n\nbashkate ~/.ssh/id_ed25519.pub\n黏贴到github中的ssh部分，创建一个新的ssh即可。\n\n配置一下global&#x2F;local的鉴权信息\n\n\ntxtgit config --global user.email &quot;your email&quot;\ngit config --global user.name &quot;your name&quot;\n如果使用代理的话，得设置一下代理【忽略这一条】\n\ntxtgit config --global http.proxy &#39;http://127.0.0.1:7890&#39;\ngit config --global https.proxy &#39;http://127.0.0.1:7890&#39;\n查看所有配置\n\nbashgit config --list\n取消代理\n\nbashgit config --global --unset http.proxy\ngit config --global --unset https.proxy\n添加谷歌dns解析\n\nbashsudo nano /etc/systemd/resolved.conf添加\ntxt[Resolve]\nDNS=8.8.8.8 8.8.4.4最后重启服务，并看一下服务状态\nbashsudo systemctl restart systemd-resolved.service\nsudo systemctl status systemd-resolved.serviceEDIT: 国内这玩意纯看玄学啊。鼓捣了半天又是dns的又是ssh-agent。还看了下终端代理，git代理，npm代理。最后把cfw设置成直连，竟然就能push了。没搞明白为什么。用了起码两个小时，真是逆了大天了。\n2. 全角标点启用和禁用\n\n\n\n\n\n\n\n\n有效的解决了每次写笔记的时候, .和。需要切换。\ntxtctrl + . 开启关闭可以在输入法的附加设置中的标点中看到。\n3. 蓝牙开机后处于禁用状态txtkate /etc/bluetooth/main.conf找到Autoenable, 取消注释, 改为true.\n","slug":"ArchLinux下GIT的配置","date":"2023-09-27T13:19:00.000Z","categories_index":"Linux","tags_index":"Linux","author_index":"Kangwei Zhu"},{"id":"24f094e932e9fa7c1ea3469108ff02c2","title":"连接远程数据库问题","content":"\n\n\n\n\n\n\n\n\n连接远程数据库时，datagrip报错：[HY000][1130] null, message from server: “Host ‘pool-100-1-119-187.nwrknj.fios.verizon.net’ is not a ……..\n已知端口开放了。问题就只能处在数据库权限上。\n查看host和对应的用户\ntxtselect host,user from mysql.user如果host是localhost的话，表明数据库只允许localhost访问，远程自然无法连接。\ntxtupdate user set host=&#39;% where user=&#39;root&#39;;让root用户能够从任意host访问到数据库。举一反三，不同的用户，将root替换成其他用户名就可以。\n最后刷新权限，再次test connection\ntxtflush privileges;SucceededDBMS: MySQL (ver. 8.0.24)  Case sensitivity: plain&#x3D;lower, delimited&#x3D;lower Driver: MySQL Connector&#x2F;J (ver. mysql-connector-java-8.0.25 (Revision: 08be9e9b4cba6aa115f9b27b215887af40b159e0), JDBC4.2)  Ping: 674 ms SSL: yes\n","slug":"连接阿里云数据库问题","date":"2023-09-21T22:35:48.000Z","categories_index":"数据库","tags_index":"Mysql","author_index":"Kangwei Zhu"},{"id":"d963b9f41994dba4a0ae074a338ebfb7","title":"探索LCU","content":"LeagueWare–仿照Wegame从零构建第三方英雄联盟客户端助手项目依赖\nxml&lt;!--JSON转Map依赖--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.13.0&lt;/version&gt;\n&lt;/dependency&gt;xml&lt;!--Lombok依赖--&gt;\n&lt;!-- https://mvnrepository.com/artifact/org.projectlombok/lombok --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;org.projectlombok&lt;/groupId&gt;\n    &lt;artifactId&gt;lombok&lt;/artifactId&gt;\n    &lt;version&gt;1.18.30&lt;/version&gt;\n    &lt;scope&gt;provided&lt;/scope&gt;\n&lt;/dependency&gt;\n注意, 不同于Web项目, JavaFX项目在引入maven依赖后, 还需要将依赖放入module-info中\n比如这样子\njavamodule com.anicaaz.leaguewarefx &#123;\n    requires javafx.controls;\n    requires javafx.fxml;\n    requires lombok;\n    requires com.fasterxml.jackson.databind;\n\n    opens com.anicaaz.leaguewarefx to javafx.fxml;\n    exports com.anicaaz.leaguewarefx;\n    exports com.anicaaz.leaguewarefx.controller;\n    opens com.anicaaz.leaguewarefx.controller to javafx.fxml;\n&#125;一些有用的资源\n\n所有版本的资源文件: https://raw.communitydragon.org/\n\n1. 获取remote-Auth-token 和 app-port\n\n\n\n\n\n\n\n\n当英雄联盟客户端正在运行时, 它会向我们的localhost暴露一个端口. 我们可以通过remote\nWindows下(需要提权)\npowershellwmic PROCESS WHERE name=&#39;LeagueClientUx.exe&#39; GET commandline Linux下\nbashps -eo pid,cmd | grep &#39;LeagueClientUx.exe&#39;\nps -eo pid,cmd: 列出所有进程的进程ID（pid）和命令行（cmd）信息。\nps: process state的简称\neo: 表示你可以制定你要的列\ncmd则是命令\n\n\ngrep &#39;LeagueClientUx.exe&#39;: 使用 grep 过滤出包含 ‘LeagueClientUx.exe’ 的行，即与你指定的进程相关的信息。\n\n然后就会得到下面这样子一长串的键值对\ntxt-riotclient-auth-token=E4z7AQD982BWJO09cYzLrA --riotclient-app-port=40465 --no-rads --disable-self-update --region=NA --locale=en_US --client-config-url=https://clientconfig.rpg.riotgames.com --riotgamesapi-standalone --riotgamesapi-settings=eyJjbGllbnQtY29uZmlnIjp7InVybCI6Imh0dHBzOi8vY2xpZW50Y29uZmlnLnJwZy5yaW90Z2FtZXMuY29tIn0sImRlZmF1bHRfcmVnaW9uIjoiTkEiLCJnbG9iYWxzIjp7InNlc3Npb24taWQiOiIxZWY1NDUxMS03OGQ2LTU3NGUtOTY1MC1lMTFiOTUyMzgwOTQifSwicGF0Y2hsaW5lX2lkIjoibGl2ZSIsInByb2R1Y3QtaW50ZWdyYXRpb24iOnsiYXBwLXVwZGF0ZS1zdGF0dXMiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS51cGRhdGUtc3RhdHVzLmpzb24iLCJoZWFydGJlYXQiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL1Jpb3QgQ2xpZW50L0RhdGEvU2Vzc2lvbnMvMWVmNTQ1MTEtNzhkNi01NzRlLTk2NTAtZTExYjk1MjM4MDk0L0U0ejdBUUQ5ODJCV0pPMDljWXpMckEuaGVhcnRiZWF0Lmpzb24iLCJsb2NrZmlsZSI6IkM6L1Byb2dyYW1EYXRhL1Jpb3QgR2FtZXMvTWV0YWRhdGEvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS9sZWFndWVfb2ZfbGVnZW5kcy5saXZlLmxvY2tmaWxlIiwic2V0dGluZ3MiOiJDOi9Qcm9ncmFtRGF0YS9SaW90IEdhbWVzL01ldGFkYXRhL2xlYWd1ZV9vZl9sZWdlbmRzLmxpdmUvbGVhZ3VlX29mX2xlZ2VuZHMubGl2ZS5wcm9kdWN0X3NldHRpbmdzLnlhbWwifSwicHJvZHVjdF9pZCI6ImxlYWd1ZV9vZl9sZWdlbmRzIiwicHVibGlzaGVyIjoicmlvdCIsInJlZ2lvbl9kYXRhIjp7Ik5BIjp7ImF2YWlsYWJsZV9sb2NhbGVzIjpbImNzX0NaIiwiZGVfREUiLCJlbF9HUiIsImVuX0FVIiwiZW5fR0IiLCJlbl9QSCIsImVuX1NHIiwiZW5fVVMiLCJlc19BUiIsImVzX0VTIiwiZXNfTVgiLCJmcl9GUiIsImh1X0hVIiwiaXRfSVQiLCJqYV9KUCIsImtvX0tSIiwicGxfUEwiLCJwdF9CUiIsInJvX1JPIiwicnVfUlUiLCJ0aF9USCIsInRyX1RSIiwidmlfVk4iLCJ6aF9NWSIsInpoX1RXIl0sImRlZmF1bHRfbG9jYWxlIjoiZW5fVVMiLCJyc28iOnsiY2xpZW50IjoibG9sIn19fSwicmlvdGNsaWVudCI6eyJhcHAtcG9ydCI6IjQwNDY1IiwiYXV0aC10b2tlbiI6IkU0ejdBUUQ5ODJCV0pPMDljWXpMckEifSwicmlvdGdhbWVzYXBpIjp7InBlcnNpc3RlbmNlLXBhdGgiOiJDOi91c2Vycy9hbmljYWEvQXBwRGF0YS9Mb2NhbC9SaW90IEdhbWVzL0xlYWd1ZSBvZiBMZWdlbmRzIn0sInJzb19hdXRoIjp7ImF1dGhvcml6YXRpb24ta2V5IjoiZXcwS0lDQWdJQ0pqYjJSbElqb2dJbVJZWTNoUGJGSnBUMVZXTUZWdFpISlZhMHAzV2xSYWVGVkZhRTFVUjA1U1RVWkZkVmxYYkVWaFdFWklVVmQzTUU5WFJrSmFNbWh6WTBSR1NtTnFiRU5hZHowOUlpd05DaUFnSUNBaVkyOWtaVjkyWlhKcFptbGxjaUk2SUNJNFNVWkxWVk4xVGs5WWFqaHpTM0p0V0RJNGVHSm5aMUkwUmxrNWVtaG9ObVk0VkZReFFuZDJaa3BVZVZCMGJqZGpWbUpvVEZKT2VrdEVVa2RvUkhWVk5sQjVhRnBmV0RKWGRsVlhVMmQzTjFjMFkxVldaeUlOQ24wPSJ9fQ== --rga-lite --remoting-auth-token=WMQXBHuk7kPpoS-QyqXm5A --respawn-command=LeagueClient.exe --respawn-display-name=League of Legends --app-port=40703 --install-directory=C:\\Riot Games\\League of Legends --app-name=LeagueClient --ux-name=LeagueClientUx --ux-helper-name=LeagueClientUxHelper --log-dir=LeagueClient Logs --crash-reporting= --crash-environment=NA1 --app-log-file-path=C:/Riot Games/League of Legends/Logs/LeagueClient Logs/2023-11-10T20-45-00_1740_LeagueClient.log --app-pid=1740 --output-base-dir=C:\\Riot Games\\League of Legends --no-proxy-server --ignore-certificate-errors\n拿到了以上输出之后, 我们就可以开始对其进行字符串处理了.\n在使用java的情况下, 我们可以用ProcessBuilder类的start方法来创建一个进程, 执行获取正在运行的英雄联盟客户端的参数.\njavapackage com.anicaaz.leaguewarefx.utils;\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.List;\n\npublic class ExecuteCommand &#123;\n\n    /**\n     * Get the token of current running lcu process.\n     * @return The Remoting-Auth-Token of cmdline output.\n     */\n    public static String getRemoteAuthToken() &#123;\n        ProcessBuilder processBuilder = new ProcessBuilder(&quot;bash&quot;, &quot;-c&quot;, &quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;);\n        String remoteAuthToken = null;\n        try &#123;\n            Process lcuProcess = processBuilder.start();\n            BufferedReader reader = new BufferedReader(new InputStreamReader(lcuProcess.getInputStream()));\n            String line;\n            while ((line = reader.readLine()) != null) &#123;\n                if (line.contains(&quot;--remoting-auth-token&quot;)) &#123;\n                    remoteAuthToken = line.split(&quot;--remoting-auth-token=&quot;)[1].split(&quot; &quot;)[0];\n                    break;\n                &#125;\n            &#125;\n        &#125; catch (IOException e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        return remoteAuthToken;\n    &#125;\n\n    /**\n     * Get the port that current lcu in running on\n     * @return The port that current lcu in running on\n     */\n    public static String getAppPort() &#123;\n        ProcessBuilder processBuilder = new ProcessBuilder(&quot;bash&quot;, &quot;-c&quot;, &quot;ps -eo cmd | grep &#39;LeagueClientUx.exe&#39;&quot;);\n        String appPort = null;\n        try &#123;\n            Process process = processBuilder.start();\n            String line;\n            BufferedReader reader = new BufferedReader(new InputStreamReader(process.getInputStream()));\n            while ((line = reader.readLine())!= null) &#123;\n                if (line.contains(&quot;--app-port&quot;)) &#123;\n                    appPort = line.split(&quot;--app-port=&quot;)[1].split(&quot; &quot;)[0];\n                    break;\n                &#125;\n            &#125;\n        &#125; catch (Exception e) &#123;\n            throw new RuntimeException(e);\n        &#125;\n        return appPort;\n    &#125;\n&#125;\n注意这里拿到了token后, 还需要\n\n先使用base64加密\n再在前面加上 Basic  注意Basic后面需要有一个空格\n\n这样,我们就获取好了向LCU API发送请求的请求参数了.\n2. LCU Api文档\n\n\n\n\n\n\n\n\nhttps://lcu.vivide.re/\n3. 向LCU API发送第一个请求.请求参数: Authorization: 处理好的token\nurl: https://localhost:{portnumber}/apixxx\n注意 请求必须是https协议\ntxthttps://127.0.0.1:40703/lol-summoner/v1/current-summoner\n访问接口测试通过后, 就可以用httpclient来模拟请求了.\nHttp请求工具类\ntxtpackage com.anicaaz.leaguewarefx.utils;\n\nimport com.fasterxml.jackson.databind.ObjectMapper;\nimport lombok.AllArgsConstructor;\nimport lombok.Data;\nimport lombok.NoArgsConstructor;\n\nimport javax.net.ssl.HttpsURLConnection;\nimport javax.net.ssl.SSLContext;\nimport javax.net.ssl.TrustManager;\nimport javax.net.ssl.X509TrustManager;\nimport java.io.IOException;\nimport java.net.HttpURLConnection;\nimport java.net.URL;\nimport java.util.Map;\n\n@Data\n@AllArgsConstructor\n@NoArgsConstructor\npublic class HttpsUtils &#123;\n\n    private String apiUrl;\n    private String requestMethod;\n\n    public Map&lt;String, Object&gt; sendHttpRequest(String authorizationToken) throws IOException &#123;\n        // 设置请求地址\n        URL url = new URL(apiUrl);\n        disableSslVerification();\n        // 打开连接\n        HttpURLConnection connection = (HttpURLConnection) url.openConnection();\n\n        // 设置请求方法\n        connection.setRequestMethod(requestMethod);\n\n        // 添加请求头，设置Authorization参数\n        connection.setRequestProperty(&quot;Authorization&quot;, authorizationToken);\n\n        // 获取响应码\n        int responseCode = connection.getResponseCode();\n        System.out.println(&quot;Response Code: &quot; + responseCode);\n\n        // 读取响应内容并将其映射到Map\n        ObjectMapper objectMapper = new ObjectMapper();\n        Map&lt;String, Object&gt; responseMap = objectMapper.readValue(connection.getInputStream(), Map.class);\n\n        // 关闭连接\n        connection.disconnect();\n\n        // 返回响应的Map\n        return responseMap;\n    &#125;\n\n    public static String constructUrl(String baseUrl, String appPort, String requestUrl) &#123;\n        return baseUrl + appPort + &quot;/&quot; + requestUrl;\n    &#125;\n\n    private void disableSslVerification() &#123;\n        try &#123;\n            TrustManager[] trustAllCerts = new TrustManager[]&#123;new X509TrustManager() &#123;\n                public java.security.cert.X509Certificate[] getAcceptedIssuers() &#123;\n                    return null;\n                &#125;\n\n                public void checkClientTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) &#123;\n                &#125;\n\n                public void checkServerTrusted(\n                        java.security.cert.X509Certificate[] certs, String authType) &#123;\n                &#125;\n            &#125;&#125;;\n\n            SSLContext sc = SSLContext.getInstance(&quot;SSL&quot;);\n            sc.init(null, trustAllCerts, new java.security.SecureRandom());\n            HttpsURLConnection.setDefaultSSLSocketFactory(sc.getSocketFactory());\n        &#125; catch (Exception e) &#123;\n            e.printStackTrace();\n        &#125;\n    &#125;\n&#125;\n注意, 这里需要禁用ssl验证. 否则会因为没有证书而一直无法发送请求.\n项目中的八股\nVolatile是什么？有什么作用？\ntxtvolatile 关键字在 Java 中用于确保变量的改变对所有线程都是可见的。它是 Java 并发编程中用来解决变量同步问题的一个关键字。在多线程环境下，volatile 确保了变量的读写操作都是直接在主内存中进行的，而不是先在各自线程的工作内存中处理，然后再写回主内存。这样一来，一个线程修改了某个 volatile 变量的值，其他线程立即就能看到这个改变。\n\n不使用 volatile 关键字可能导致的问题：\n\n可见性问题：如果一个线程修改了一个非 volatile 变量的值，其他线程可能看不到这个改变。这是因为每个线程可能有自己的本地内存（线程缓存），而非 volatile 变量的值可能仅在一个线程的本地内存中更新，而没有被写回主内存。\n\n指令重排序：在没有 volatile 关键字的情况下，编译器可能会重新排序代码中的指令，以优化性能。这可能会破坏程序的逻辑流程，尤其是在并发环境中。而 volatile 变量会限制这种重排序。\n\n在你的案例中，如果不使用 volatile 关键字，那么当 stopRequested 在一个线程中被修改时，正在运行 monitorButtonClick 方法的另一个线程可能无法立即看到这个改变。这可能会导致线程不会如预期的那样停止。\n\n总的来说，如果你正在处理多线程环境中的共享变量，并且这些变量可能会被多个线程同时读写，那么使用 volatile 关键字是一种简单有效的保证变量状态对所有线程都一致可见的方法。然而，它并不处理更复杂的原子性问题（比如计数器递增等操作），这种情况下需要使用其他的同步机制，如 synchronized 或 java.util.concurrent 包下的类。\n\n","slug":"2023-07-11-探索LCU","date":"2023-07-10T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"},{"id":"a8cb7e5b0948656e80258acbb14ae2c8","title":"多线程笔记","content":"Thread的三种创建方式1. 继承Thread类\n\n\n\n\n\n\n\n\n重写run()方法。将run()方法中内容替换成你想要的代码逻辑。然后创建这个线程的对象，调用start()方法开启线程。\n\n调用run()方法，必然先执行run方法内部的代码，之后才会执行run后面的代码。而调用start()方法，则会交替执行run内部代码以及run后面的代码。\n这个现象表明了一点：当线程开启时，线程不一定立刻执行。具体执行顺序得看CPU调度.\nDemo: MyThread &amp; MutiThreadDownloadDemo\n\njavapackage com.anicaaz.thread;\n\npublic class MyThread extends Thread&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyThread myThread = new MyThread();\n        myThread.start();\n\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start方法被执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;javapackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class MutiThreadDowloadDemo extends Thread&#123;\n    private String url;\n    private String filename;\n\n    public MutiThreadDowloadDemo(String url, String filename) &#123;\n        this.url = url;\n        this.filename = filename;\n    &#125;\n\n\n    @Override\n    public void run() &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.filename);\n        System.out.println(&quot;下载了文件名&quot; + this.filename);\n    &#125;\n\n    public static void main(String[] args)&#123;\n        MutiThreadDowloadDemo mutiThreadDowloadDemo1 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;1.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo2 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;2.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo3 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;3.jpg&quot;);\n        MutiThreadDowloadDemo mutiThreadDowloadDemo4 = new MutiThreadDowloadDemo(&quot;https://chat.openai.com/_next/image?url=https%3A%2F%2Flh3.googleusercontent.com%2Fa%2FAAcHTteDEwXv8n1Vcl-AYHV_xJiVvLGncsiVtvqACj0V8mp5ag%3Ds96-c&amp;w=48&amp;q=75&quot;, &quot;4.jpg&quot;);\n        mutiThreadDowloadDemo1.start();\n        mutiThreadDowloadDemo2.start();\n        mutiThreadDowloadDemo3.start();\n        mutiThreadDowloadDemo4.start();\n    &#125;\n&#125;javapackage com.anicaaz.thread;\n\nimport org.apache.commons.io.FileUtils;\n\nimport java.io.File;\nimport java.io.IOException;\nimport java.net.URL;\n\npublic class Downloader&#123;\n    public void download(String url, String filename) &#123;\n        try &#123;\n            FileUtils.copyURLToFile(new URL(url), new File(filename));\n        &#125; catch (IOException e) &#123;\n            e.printStackTrace();\n            System.out.println(&quot;URL对象创建失败&quot;);\n        &#125;\n    &#125;\n&#125;\n2. 实现Runnable接口\n\n\n\n\n\n\n\n\n定义一个实现了Runnable接口的类，实现Runnable接口中的run()方法。创建一个Thread对象，并将这个实现Runnable接口的类的对象作为创建Thread对象时的参数。最后调用thread对象的start()方法，开启线程\n\n本质是代理的思想。\nThread类其实也实现了Runnable接口。\nDemo: MyRunnable\n\njavapackage com.anicaaz.thread;\n\npublic class MyRunnable implements Runnable&#123;\n\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;run方法被执行了&quot; + i);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable();\n        Thread thread = new Thread(myRunnable);\n        thread.start();\n        for (int i = 0; i &lt; 100; i++) &#123;\n            System.out.println(&quot;start后面的代码执行了&quot; + i);\n        &#125;\n    &#125;\n&#125;\n\n思考：将MutiThreadDownload改造成实现Runnable接口方式\n\n2.1 两种创建方式的对比\n\n\n\n\n\n\n\n\n和第一种方法的区别在于更加灵活。创建一个实现Runnable接口的对象，可以让多个Thread共享。而第一种方法则有点不灵活，因为java是单继承的oop语言。继承了Thread类，那么别的类就继承不了了。\n2.2 初识并发问题\n\n\n\n\n\n\n\n\n火车票，多人抢了同一张票。\n\nDemo: TrainTicketDemo\n\njavapackage com.anicaaz.thread;\n\npublic class TrainTicketDemo implements Runnable &#123;\n    private int ticketNumber = 10;\n\n    @Override\n    public void run() &#123;\n        while (true) &#123;\n            if (ticketNumber &lt;= 0) &#123;\n                break;\n            &#125;\n            try &#123;\n                Thread.sleep(1000);\n            &#125; catch (InterruptedException e) &#123;\n                throw new RuntimeException(e);\n            &#125;\n            System.out.println(Thread.currentThread().getName() + &quot;抢到了第&quot; + ticketNumber-- + &quot;张票&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        TrainTicketDemo train = new TrainTicketDemo();\n        Thread xiaoming = new Thread(train, &quot;小明&quot;);\n        Thread xiaofang = new Thread(train, &quot;小芳&quot;);\n        Thread xiaoli = new Thread(train, &quot;小李&quot;);\n        xiaoming.start();\n        xiaofang.start();\n        xiaoli.start();\n    &#125;\n&#125;\n3. 实现Callable接口\n\n\n\n\n\n\n\n\n创建一个类，实现Callable接口，重写call()方法，需要返回值类型, 方法上面需要抛出异常。然后创建ExecutorService（执行服务）接口的对象, 然后调用submit()方法提交执行，并启动该线程。可以用Future&lt;&gt;来获取提交后的结果。并用Future对象的get()方法来获得call()方法的返回值。\n\nDemo: MyCallable\n\njava    package com.anicaaz.thread;\n\nimport java.util.concurrent.*;\n\npublic class MyCallable implements Callable&lt;Boolean&gt; &#123;\n    private String url;\n    private String fileName;\n\n    public MyCallable(String url, String fileName) &#123;\n        this.url = url;\n        this.fileName = fileName;\n    &#125;\n\n    @Override\n    public Boolean call() throws Exception &#123;\n        Downloader downloader = new Downloader();\n        downloader.download(this.url, this.fileName);\n        System.out.println(&quot;下载了&quot; + url + &quot; 地址的&quot; + fileName + &quot;文件&quot;);\n        return true;\n    &#125;\n\n    public static void main(String[] args) throws ExecutionException, InterruptedException &#123;\n        MyCallable myCallable1 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;1.png&quot;);\n        MyCallable myCallable2 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;2.png&quot;);\n        MyCallable myCallable3 = new MyCallable(&quot;https://www.baidu.com/img/PCtm_d9c8750bed0b3c7d089fa7d55720d6cf.png&quot;, &quot;3.png&quot;);\n        ExecutorService executorService = Executors.newFixedThreadPool(3);\n        Future&lt;Boolean&gt; f1 = executorService.submit(myCallable1);\n        Future&lt;Boolean&gt; f2 = executorService.submit(myCallable2);\n        Future&lt;Boolean&gt; f3 = executorService.submit(myCallable3);\n        boolean res = f1.get();\n        System.out.println(res);\n        executorService.shutdown();\n    &#125;\n&#125;\n补票： 静态代理模式\n\n\n\n\n\n\n\n\n其实就是一个接口，两个类实现。其中一个类是代理，一个类是被代理。代理中成员变量需要包含被代理类对象。这两个实现类都重写了接口中的方法。正是因为这样，代理类中的方法，不仅可以调用被代理对象重写的方法，还可以在自身重写的方法内部干别的事情。我们只需要创建两个类对象，并将被代理者作为创建代理对象时候的参数传入，即可实现这个模式。\n\nRunnable接口实现类和Thread的关系\nDemo： StaticProxyDemo\n\njavapackage com.anicaaz.thread;\n\npublic class StaticProxyDemo &#123;\n    public static void main(String[] args) &#123;\n        You you = new You();\n        WeddingCompany weddingCompany = new WeddingCompany(you);\n        weddingCompany.getMarried();\n    &#125;\n&#125;\n\ninterface Marry &#123;\n    void getMarried();\n&#125;\n\nclass You implements Marry &#123;\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;你结婚了&quot;);\n    &#125;\n&#125;\n\nclass WeddingCompany implements Marry &#123;\n    private You you;\n\n    public WeddingCompany(You you) &#123;\n        this.you = you;\n    &#125;\n\n    @Override\n    public void getMarried() &#123;\n        System.out.println(&quot;定酒店&quot;);\n        System.out.println(&quot;布置&quot;);\n        you.getMarried();\n        System.out.println(&quot;收拾&quot;);\n        System.out.println(&quot;结账&quot;);\n    &#125;\n&#125;\n4. Lamda表达式 (package: lambda)\n\n\n\n\n\n\n\n\n任何接口，如果只包含一个抽象方法，那么它就是一个函数式接口,如下。其中，方法名可以简化为 void run();\njavapublic interface MyRunnable &#123;\n    public abstract void run(); // =&gt; void run();\n&#125;对于函数式子接口，我们可以使用Lambda表达式来进行简化（创建该接口的对象）。\n4.1 Lambda的演化过程:4.1.1 传统写法：创建实现类对象，调用接口方法。javapublic class TestLambda1 implements MyRunnable&#123;\n\n    /**\n     * 标准的实现方法。\n     */\n    @Override\n    public void run() &#123;\n        System.out.println(&quot;标准的实现方法&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new TestLambda1();\n        myRunnable.run();\n    &#125;\n&#125;4.1.2 静态内部类写法javapackage com.anicaaz.lambda;\n\npublic class TestLambda2 &#123;\n\n    static class MyRunnableImpl implements MyRunnable &#123;\n        @Override\n        public void run() &#123;\n            System.out.println(&quot;静态内部类实现&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n\n&#125;4.1.3 局部内部类写法javapackage com.anicaaz.lambda;\n\npublic class TestLambda3 &#123;\n\n    public static void main(String[] args) &#123;\n        class MyRunnableImpl implements MyRunnable &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;局部内部类写法&quot;);\n            &#125;\n        &#125;\n\n        MyRunnable myRunnable = new MyRunnableImpl();\n        myRunnable.run();\n    &#125;\n&#125;4.1.4 匿名内部类写法没有类的名字\njavapackage com.anicaaz.lambda;\n\npublic class TestLambda4 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = new MyRunnable() &#123;\n            @Override\n            public void run() &#123;\n                System.out.println(&quot;匿名内部类写法&quot;);\n            &#125;\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;4.1.5 Lambda写法javapackage com.anicaaz.lambda;\n\npublic class TestLambda5 &#123;\n    public static void main(String[] args) &#123;\n        MyRunnable myRunnable = () -&gt; &#123;\n            System.out.println(&quot;Lambda 写法&quot;);\n        &#125;;\n        myRunnable.run();\n    &#125;\n&#125;Lambda的主要作用是避免内部类过多\nLambda还存在多种写法。根据参数，方法内代码行数的不同，是否能省略也不一样。如果参数只有一个，可以省略括号。如果行数只有一行，可以省略大括号。\njavapackage com.anicaaz.lambda;\n\npublic class MyRunnableImpl2 &#123;\n\n    public static void main(String[] args) &#123;\n        MyRunnable2 myRunnable2 = null;\n\n        //写法1： 省略参数类型\n        myRunnable2 = (a, b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1, 2);\n\n        //写法2： 不省略参数类型\n        myRunnable2 = (int a, int b) -&gt; &#123;\n            System.out.println(a + b);\n        &#125;;\n        myRunnable2.run(1 , 2);\n    &#125;\n&#125;5. 线程状态  (package: threadState)\n新生\n\n\n\n\n\n\n\n\n线程的创建\n\n\njavaThread thread = new Thread();\n就绪\n\njavathread.start();\n运行start之后，抢占到cpu资源。cpu调度开始执行。\n阻塞调用wait， sleep， 或同步锁定后，线程进入阻塞状态，阻塞状态解除后，重新进入就绪状态，等待cpu调度执行\n死亡线程中断或结束，就进入死亡状态，无法重新启动。\n\n5.1 如何停止线程\n\n\n\n\n\n\n\n\n建议使用flag停止线程。不建议使用destory()、stop()进行停止。\njavapackage com.anicaaz.threadState;\n\npublic class StopDemo implements Runnable&#123;\n\n    private boolean flag;\n\n    @Override\n    public void run() &#123;\n        while (flag) &#123;\n            System.out.println(&quot;线程正在运行&quot;);\n        &#125;\n    &#125;\n\n    public void stop() &#123;\n        this.flag = false;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        StopDemo runnable = new StopDemo();\n        Thread thread = new Thread(runnable);\n        thread.start();\n        for (int i = 0; i &lt; 1000; i++) &#123;\n            if (i == 900) &#123;\n                runnable.stop();\n                System.out.println(&quot;线程停止了&quot;);\n            &#125; else &#123;\n                System.out.println(&quot;main&quot; + i);\n            &#125;\n        &#125;\n    &#125;\n&#125;5.2 Sleep 线程阻塞(休眠)\nsleep中的参数指的是当前线程阻塞的毫秒数\n需要抛InterruptedException\nsleep之间到达之后线程进入阻塞状态\n每个对象都有一个锁，sleep不会释放锁\n\nDemo： 打表\njavapackage com.anicaaz.threadState;\n\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\n\npublic class SleepDemo &#123;\n    public static void main(String[] args) throws InterruptedException &#123;\n        Date currentTime = new Date(System.currentTimeMillis());\n        while (true) &#123;\n            System.out.println(new SimpleDateFormat(&quot;HH:mm:ss&quot;).format(currentTime));\n            Thread.sleep(1000);\n            currentTime = new Date(System.currentTimeMillis());\n        &#125;\n    &#125;\n&#125;5.3 Yield，线程礼让\n\n\n\n\n\n\n\n\n礼让线程，让当前正在执行的线程暂停，但不阻塞让线程从运行状态转为就绪状态让cpu重新调度。注意，就算当前线程礼让了，依旧有可能出现不成功的现象\njavapackage com.anicaaz.threadState;\n\nimport com.anicaaz.lambda.MyRunnable;\n\npublic class YieldDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        System.out.println(Thread.currentThread().getName() + &quot;线程开始执行&quot;);\n        Thread.yield();\n        System.out.println(Thread.currentThread().getName() + &quot;线程停止执行&quot;);\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new YieldDemo();\n        Thread t1 = new Thread(runnable);\n        Thread t2 = new Thread(runnable);\n        t1.start();\n        t2.start();\n    &#125;\n&#125;5.4 join线程强制执行\n\n\n\n\n\n\n\n\n可以看作是线程的插队。比如两个线程同时执行，其中一个线程调用join()方法，则另一个线程必须等到这个线程执行完毕后才能执行。\njavapackage com.anicaaz.threadState;\n\npublic class JoinDemo implements Runnable&#123;\n    @Override\n    public void run() &#123;\n        for (int i = 0; i &lt; 300; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n        &#125;\n    &#125;\n\n    public static void main(String[] args) &#123;\n        Runnable runnable = new JoinDemo();\n        Thread thread = new Thread(runnable, &quot;vip&quot;);\n        thread.start();\n        for (int i = 0; i &lt; 500; i++) &#123;\n            System.out.println(Thread.currentThread().getName() + i + &quot;正在执行&quot;);\n            if (i == 100) &#123;\n                try &#123;\n                    thread.join();\n                &#125; catch (InterruptedException e) &#123;\n                    throw new RuntimeException(e);\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#125;","slug":"多线程","date":"2023-03-11T21:02:04.000Z","categories_index":"Java基础","tags_index":"Java多线程","author_index":"Kangwei Zhu"},{"id":"9fe79a5e2d58fcbcba8e87cdea7a0f13","title":"Spring笔记","content":"Spring复习笔记\n\n\n\n\n\n\n\n\nSpring是开源的免费框架\n轻量级、非入侵式的\nIOC控制反转， AOP面向切面编程 \t\t\t\t\t是重点\n支持事务，对框架·整合的指出\t\t\t\t\t\t\t也是重点\n总结一句话。Spring就是一个轻量级的控制反转和面向切面编程的框架。\nLC1. 任何项目，首先先导这两个maventxt1. spring-webmvc\n2. spring-jdbc\n\n第一个webmvc包含了很多spring的包，比如spring-core，spring-context。这样就不用多次导入不同的包了。\n\n第二个jdbc是用来整合mybatis连接数据库的\nLC2. Spring简介\n\n\n\n\n\n\n\n\n\nSpringboot快速开发的脚手架。基于springboot可以快速开发单个微服务.\n\nSpringcloud是基于springboot实现的。\n\n\nSpring起到了承上启下的作用。\n弊端： 发展了太久，违背了原来的理念。\n\n\n\n\n\n\n\n\n\nLC3. Spring IOC\n以前写业务\n\nUserDao接口\n\nUserDaoImpl实现类(会有多个)\n\nUserService 业务接口\n\nUserServiceImpl业务实现类(会有多个)\n\n\n\n\n\n在我们之前的业务中，用户的需求可能会影响我们原来的代码，我们需要根据用户的需求去修改源代码。\n改进1：\n这样就可以动态的注入UserDao到UserServiceImpl中，避免写死。\n也就是主动型变了。原来是程序主动创建对象，现在是程序被动接受一个对象。系统的耦合性降低。\nLC4: IOC本质\n采用XML方式配置Bean的时候，Bean的定义信息是和实现分离的，而采用注解的方式可以把两者何为一体。Bean的定义信息直接以注解的形式定义再类中，从而达到了零配置的目的。\n控制反转是一种通过描述（XML或注释），并通过第三方去生产或获取特定对象的方式。在Spring中实现控制反转的是IoC容器。其实现方式是依赖注入（Dependency Injection）。\n\n大白话理解Ioc就是。原本对象的创建都是由程序员来控制的。而现在，通过XML中写这些bean标签，以及使用Autowire等注解进行开发，可以让Spring Ioc容器帮我们来创建对象并完成对象的配置。程序员因此只需要获取这些由spring创建好的对象即可\nLC5: Bean Definition Inheritance (Bean标签的理解)\n\n\n\n\n\n\n\n\n“Bean definition can contain a lot of configuration information, including constructor arguments, property values, and container-specific information, such as the initialization method, a static factory method name, and so on. “\n需要掌握的代码\njavaApplicationContext applicationConext = new ClassPathXmlApplicationContext(&quot;BeanName.xml&quot;);LC6. Spring对象的创建\nSpring容器默认使用无参构造创建对象\n假如需要使用有参构造创建对象， 三种方式 \n下标 index\n参数类型 type   -&gt; 不建议使用，多个同类型的参数，会乱。\n直接通过参数名 name.\n也可以用ref 对象的方法。和通过参数名类似。\n\n\n\n\n\n总结： 在配置文件加载的时候，容器中管理的对象就已经被初始化了。\n\n\n\n\n\n\n\n\n\n面试： BeanFactory相关。\nBeanFactory是什么？FactoryBean又是什么？Bean存哪里, 怎么存？ BeanPostProcessor是什么？ 这些高频面试题都不讲，确实拉了\n1.BeanPostProcessor 是什么？\n\n\n\n\n\n\n\n\n“The BeanPostProcessor interface defines callback methods that you can implement to provide your own (or override the container’s default) instantiation logic, dependency resolution logic, and so forth. If you want to implement some custom logic after the Spring container finishes instantiating, configuring, and initializing a bean, you can plug in one or more custom BeanPostProcessor implementations.”\n首先， BeanPostProcessor是一个接口，定义了一些方法，来实现你对于对象创建时初始化的逻辑。当Spring Ioc容器实例化bean之后，BeanPostProcessor就开始工作了。\nLC7. Spring配置详解1. 别名 标签的name和alias都是别名。getBean的时候，使用这两个标签配置的对象都可以被get到。\n使用name时，可以同时取多个别名。别名可以逗号，空格，分号分隔。\n2. Import将多个配置文件导入到一个xml, 通常是把所有的xml导入到applicaitonContext.xml下\nxml&lt;import resource=&quot;beans1.xml&quot;&gt;\n&lt;import resource=&quot;beans2.xml&quot;&gt;    \n&lt;import resource=&quot;beans3.xml&quot;&gt;    LC8. 依赖注入1. 构造器注入​\t前面讲过了\nxml&lt;constructor-arg&gt;2. Set方式注入\n\n\n\n\n\n\n\n\n各种数据类型的注入\n\n3. 拓展方式注入命名空间注入：\n比如 p命名空间，直接能够注入property\ntxt&lt;beans id=&quot;xxx&quot; class=&quot;com.xxx.xxx&quot; p:name=&quot;xxx&quot; p:age=&quot;11&quot;;以及  c命名空间，其实就是constructor-arg\nLC9. Bean的作用域\n单例模式（默认）\n原型模式\n\nLC10. Bean的自动装配\n\n\n\n\n\n\n\n\n\n如果是byName，那么你的bean的id 必须严格遵守你在pojo里面定义的set方法中的后缀名。比如pojo中一个方法叫setXxx()。 注意本例中Xxx是一个引用类型的对象，那么，在你的bean id里面，只能写xxx（全小写，否则报错）。不能写xxx1   xxx2 ，Xxx 会报错\n而byType相反。你bean id想怎么写就怎么写。 管你xxx1 1xxx  xx1x, 只要class 是 com.example.xxx, spring都能通过反射创建你的对象.\n\nSpring 在 2.5版本提供了对注解的支持。如果要使用注解，需要导入context约束。\n可以直接去Spring官网复制黏贴代码就可以。节约时间。\n链接： https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-annotation-config\nxml&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;\n    xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;\n    xmlns:context=&quot;http://www.springframework.org/schema/context&quot;\n    xsi:schemaLocation=&quot;http://www.springframework.org/schema/beans\n        https://www.springframework.org/schema/beans/spring-beans.xsd\n        http://www.springframework.org/schema/context\n        https://www.springframework.org/schema/context/spring-context.xsd&quot;&gt;\n\n    &lt;context:annotation-config/&gt;\n\n&lt;/beans&gt;\n复制完这个配置类之后，我们的spring就可以通过注解来实现自动装配了。\n补充:\ntxt&lt;context:annotation-config/&gt; 隐式的注册了以下的PostProcessors\n\n    ConfigurationClassPostProcessor\n\n    AutowiredAnnotationBeanPostProcessor\n\n    CommonAnnotationBeanPostProcessor\n\n    PersistenceAnnotationBeanPostProcessor\n\n    EventListenerMethodProcessor\n\n1. Autowired可以用在哪里\n构造器上\n\n注意! 如果由多个constructor并且没有无参构造的话，至少得有一个constructor上面需要加autowired. 这样Ioc才知道用什么。\ntxtAs of Spring Framework 4.3, an @Autowired annotation on such a constructor is no longer necessary if the target bean defines only one constructor to begin with. However, if several constructors are available and there is no primary/default constructor, at least one of the constructors must be annotated with @Autowired in order to instruct the container which one to use. See the discussion on constructor resolution for details.\n\n\n传统的set方法上\n\n\njavapublic class SimpleMovieLister &#123;\n\n    private MovieFinder movieFinder;\n\n    @Autowired\n    public void setMovieFinder(MovieFinder movieFinder) &#123;\n        this.movieFinder = movieFinder;\n    &#125;\n\n    // ...\n&#125;\n带参的方法上\ntxtpublic class MovieRecommender &#123;\n\n    private MovieCatalog movieCatalog;\n\n    private CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    public void prepare(MovieCatalog movieCatalog,\n            CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.movieCatalog = movieCatalog;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n成员变量和构造方法上\njavapublic class MovieRecommender &#123;\n\n    private final CustomerPreferenceDao customerPreferenceDao;\n\n    @Autowired\n    private MovieCatalog movieCatalog;\n\n    @Autowired\n    public MovieRecommender(CustomerPreferenceDao customerPreferenceDao) &#123;\n        this.customerPreferenceDao = customerPreferenceDao;\n    &#125;\n\n    // ...\n&#125;\n\n如果想让Spring为相同类型的多个bean的话，可以使用数组、集合\ntxtpublic class MovieRecommender &#123;\n\n    @Autowired\n    private MovieCatalog[] movieCatalogs;\n\n    // ...\n&#125;\n\npublic class MovieRecommender &#123;\n\n    private Set&lt;MovieCatalog&gt; movieCatalogs;\n\n    @Autowired\n    public void setMovieCatalogs(Set&lt;MovieCatalog&gt; movieCatalogs) &#123;\n        this.movieCatalogs = movieCatalogs;\n    &#125;\n\n    // ...\n&#125;\n\n\n\n2. Autowire失败条件\n\n\n\n\n\n\n\n\nutowiring fails when no matching candidate beans are available for a given injection point.\n3. @Autowiresd(required&#x3D; false) 意思txtIn other words, setting the required attribute to false indicates that the corresponding property is optional for autowiring purposes, and the property will be ignored if it cannot be autowired. This allows properties to be assigned default values that can be optionally overridden via dependency injection.其实就是不需要，但是有机会还是想注入。替代方案有Java.util.Optional 和  Nullable。\n4. 什么是Qualifier\n\n\n\n\n\n\n\n\n多个同类型的bean实现autowire的时候使用\nxml@AutoWired\n@Qualifier(value=xxx1)\nprivate Dog dog;\n\n\n\n\n&lt;xml ....&gt;\n\n&lt;bean id=&#39;xxx1&#39; class=&quot;dog&quot;&gt;\n&lt;bean id=&quot;xxx&quot;, class = &quot;dog&quot;&gt;\n5. Resource注解\nJavax.annotation.resource\nIoc查找时。要么xml中只有一个该类型bean。要么bean id和set后缀想通同。不然找不到。也可以用name来找到。\n引申问题： Resource和Autowire的区别？\nLC11 注解开发关键字：@ component\n在spring4之后，需要导入aop包，来开启注解开发。\ntxtspring-aop流程：\n\nxml &lt;context:annotation-config&gt; \n \nxml &lt;context:component-scan base-package=&quot;com.example.xxx&quot;&gt;\n &lt;!--这里 base-package是指定要扫描的包。这个包下的所有注解都会生效--&gt;\n\n@component 挂在类上，代表这个类被spring管理了\n@Value挂在变量上面，代表这个变量的值\njava@Value(&quot;anicaa&quot;)\nprivate String name;\n也可以挂在set方法上。同理\njava@Value(&quot;anicaa&quot;)\npublic void setName(String name)&#123;\n    this.name = name;\n&#125;\n\n@Scope，就是决定单例，多例的注解。同样挂在类上。\njava@Scope(&quot;prototype&quot;)\n@Scope(&quot;singleton&quot;)@components注解的衍生\n\n\n\n\n\n\n\n\n在web开发中，我们会按照model-view-controller三层架构来分层。\n\ndao层\nservice层\ncontroller层\n\n每层的注解都是特种的。dao 是 @Repository, serivce是 @Service, controller 是 @Controller。\nLC12. 使用纯Java配置Spring\n\n\n\n\n\n\n\n\n旨在离开xml配置，只使用java就能完成配置。\njava//UserConfig类\n\npackage com.example.config;\n\n\nimport com.example.pojo.User;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class UserConfig &#123;\n\n    @Bean\n    public User getUser()&#123;\n        return new User();\n    &#125;\n\n&#125;\njava//User类\n\npackage com.example.pojo;\n\nimport org.springframework.beans.factory.annotation.Value;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class User &#123;\n    @Value(&quot;anicaa&quot;)\n    private String name;\n\n    public String getName()&#123;\n        return this.name;\n    &#125;\n&#125;\njava测试代码\npackage com.example.springconfig;\n\nimport com.example.config.UserConfig;\nimport com.example.pojo.User;\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.context.ApplicationContext;\nimport org.springframework.context.annotation.AnnotationConfigApplicationContext;\n\npublic class SpringConfigApplication &#123;\n\n    public static void main(String[] args) &#123;\n        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(UserConfig.class);\n        User user = (User) applicationContext.getBean(&quot;getUser&quot;);\n        System.out.println(user.getName());\n    &#125;\n&#125;\n\n挂在方法上的@Bean, 其方法名就是bean id。返回值就是Bean class.\n\n@ComponentScan(“com.exmaple.xxx”). 挂在config类头上，就是扫描。\n\n@Import() 导入别的config类.\n\n\nLC13. AOP\n\n\n\n\n\n\n\n\nSpring中比较重要的模式： 代理模式 和 工厂模式\n设计模式-代理模式（AOP底层）1. 静态代理\n\n\n\n\n\n\n\n\n静态代理的静态，体现在他的代理是被“写死的“。以UserService以及其接口的实现类为例\n\nUser Service接口\n\njavapackage com.example.test;\n\npublic interface UserService &#123;\n    public void add();\n    public void delete();\n    public void query();\n    public void update();\n&#125;\n\nUserServiceImpl 实现类\n\njavapackage com.example.test;\n\npublic class UserServiceImpl implements UserService&#123;\n\n\n    @Override\n    public void add() &#123;\n        System.out.println(&quot;添加了&quot;);\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        System.out.println(&quot;删除了&quot;);\n    &#125;\n\n    @Override\n    public void query() &#123;\n        System.out.println(&quot;查询了&quot;);\n    &#125;\n\n    @Override\n    public void update() &#123;\n        System.out.println(&quot;更新了&quot;);\n    &#125;\n&#125;\n\nUserServiceProxy 静态代理类。\n\ntxtpackage com.example.test;\n\nimport com.example.pojo.User;\n\npublic class UserServiceProxy implements UserService &#123;\n    private UserServiceImpl userService;\n\n    public UserServiceProxy()&#123;\n\n    &#125;\n\n    public UserServiceProxy(UserServiceImpl userService)&#123;\n        this.userService = userService;\n    &#125;\n\n    @Override\n    public void add() &#123;\n        log(&quot;add&quot;);\n        userService.add();\n    &#125;\n\n    @Override\n    public void delete() &#123;\n        log(&quot;delete&quot;);\n        userService.delete();\n    &#125;\n\n    @Override\n    public void query() &#123;\n        log(&quot;query&quot;);\n        userService.query();\n    &#125;\n\n    @Override\n    public void update() &#123;\n        log(&quot;update&quot;);\n        userService.update();\n    &#125;\n\n    public void log(String str)&#123;\n        System.out.println(&quot;call &quot; + str);\n    &#125;\n&#125;\n4.Client 类. 调用了代理，执行接口的放法。\ntxtpackage com.example.test;\n\npublic class Client &#123;\n    public static void main(String[] args) &#123;\n        UserServiceImpl userService = new UserServiceImpl();\n        UserServiceProxy userServiceProxy = new UserServiceProxy(userService);\n        userServiceProxy.add();\n        userServiceProxy.delete();\n        userServiceProxy.query();\n        userServiceProxy.update();\n    &#125;\n&#125;\n在这里, 写死体现在了静态代理类中的log方法。这种需要经常改动的类，可以通过InvocationHandler来实现动态的改动。\n2. 动态代理\n\n\n\n\n\n\n\n\n而动态代理的作用就在于，不需要申明一个代理类。只需一个InvocationHandler就可以作为模板，动态的代理多个接口。\n在代理模式中，接口可以被看作是房东。而接口的实现类，以及实现类中的方法，就是房东的房子里的房间。\n原先，我们需要创建一个静态代理类，来管理这些实现类，以及调用实现类中的方法。这就像是房东找了中介来出租房子里的每个房间。\n现在，通过动态代理。我们可以直接把房子交给中介。也就是把实现类交给InvocationHandler\njavasetTarget(Object target)就能设定需要代理的接口。InvocationHandler会通过反射，找到实现类所对应的接口，并把这个接口返回给我们。之后，Client可以直接通过这个返回来的对象调用其方法，实现代理。\n\nInvocationHandler\n\ntxtpackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    \n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\n\nClient\n\ntxtpackage com.example.test;\n\nimport java.lang.reflect.InvocationHandler;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Proxy;\n\npublic class UserServiceInvocationHandler implements InvocationHandler &#123;\n    //被代理的对象\n    private Object target;\n\n    //获取代理对象\n    public Object getProxy()&#123;\n        return Proxy.newProxyInstance(this.getClass().getClassLoader(), target.getClass().getInterfaces(),this);\n    &#125;\n\n    public void setTarget(Object target)&#123;\n        this.target = target;\n    &#125;\n    //代理对象以及代理调用方法时候，都会invoke这个\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable &#123;\n        log(method.getName());\n        return method.invoke(target, args);\n    &#125;\n\n    private void log(String msg)&#123;\n        System.out.println(&quot;Calling&quot; + msg);\n    &#125;\n&#125;\nLC14. Spring AOP","slug":"Spring笔记","date":"2023-02-12T01:34:49.000Z","categories_index":"后端开发","tags_index":"Spring","author_index":"Kangwei Zhu"},{"id":"c5b4816193947aa93e977c106cb13634","title":"接口测试","content":"1. 回顾1.1 URLURL： 统一资源定位符\n格式： 协议:&#x2F;&#x2F;hostname:port&#x2F;path?参数&#x3D;值&amp;参数2&#x3D;值\n默认端口号可以不写\nhttp:80\nhttps:443\n1.2 HTTP &#x2F; HTTPS超文本传输协议。基于响应和请求的应用层协议\n规定了客户端和服务器之间信息的传递规范。\n组成：\n\nHTTP请求定义了请求数据格式\nHTTP响应定义了响应数据格式\n\n1.2.1 HTTP 请求行位于请求数据的第一行。表明了请求方式，访问的资源，协议版本\n格式：[请求方法] [url] [协议&#x2F;协议版本]\n常用请求方法：\n\nPOST 在服务器新建一个资源\nGET 从服务器获取资源\nDELETE 从服务器删除资源\nPUT 在服务器更新资源\n\n1.2.2 HTTP 请求头\n\n\n\n\n\n\n\n\nRequest-header\n位于请求数据的第二行到空白行之间。作用是通知服务器客户端的请求信息。请求头部由键值对组成。每行一对。\n常见的参数：\nHost、User-Agent、Content-Type\nContent-Type用于表明请求体的数据类型，通常有：\n\ntext&#x2F;html\nimage&#x2F;jpeg\napplication&#x2F;json\napplication&#x2F;x-www-form-urlencoded\nmutipart&#x2F;form-data\n\n1.2.3 HTTP 请求体\n\n\n\n\n\n\n\n\nRequest-body\nbody-parameters\n请求体就是请求下面的空白行下面的内容。常配合的请求头有上面讲的Content-Type，标明请求体的类型。还有Content-Length，标明请求体的长度。\n\n请求报文可以没有请求体\n\n1.2.4 HTTP 响应 - 状态行处于响应数据第一行。用于描述服务器处理结果\n格式：【协议版本号】【状态码】【状态消息】\n状态码：三位数字\n\n1xx: 指示信息\n2xx: 成功\n3xx: 重定向\n4xx: 客户端错误\n5xx: 服务端错误\n\n1.2.5 HTTP 响应 - 响应头和请求头的位置一样。用于描述客户端想要的一些附加信息。同样由键值对组成\n1.2.6 HTTP 响应 - 响应体和请求体位置一样。数据类型类似。是服务器返回的数据实体。\n2. Charles\n\n\n\n\n\n\n\n\n下载地址：https://www.charlesproxy.com/download/\n激活：https://www.zzzmode.com/mytools/charles/\n2.1 什么是CharlesCharles，是一个基于HTTP协议的代理服务器。通过成为电脑或者是浏览器的代理，从而截取请求和请求结果，以达到抓包分析的目的。\n2.2 Charles 工作流程Charles的工作流程，其实就是在主机和互联网之间，加一个代理服务器。主机发送请求的时候，先发到charles上，由charles转发给服务器。接受时候同理。\n2.3 Charles功能\n支持HTTP和HTTPS代理\n支持流量控制（弱网环境）\n支持接口并发请求\n支持重发网络请求\n支持断点调试（构建异常的测试场景）\n\n2.4 补票3. 接口规范3.1 传统接口风格URL体现了业务增删改查操作。\nhttp://localhost:80/user/getAllUsers\nhttps://localhost:80/deleteUser?id=1\n这种就是传统的接口\n3.2 RESTful接口风格URL中只定义了需要操作的对象。\nhttps://localhost:80/app/users/1 : 操作user集合的中编号为1的对象。\n\n请求API的URL用来定位资源（也就是对象）。\n\n通过HTTP请求方式，来对资源进行增删改查操作。\n\n查：GET\n增：POST\n改：PUT\n删：DELETE\n\n\n状态码遵循HTTP状态码协议。\n\n\n4. 业务流程 vs 单个模块拿到一个项目后，先测试业务流程，确保核心功能正常。\n4.1 如何设计业务流程测试用例\n根据流程图，找业务路径\n根据业务路径分析对应的接口请求\n将业务路径转化为接口测试用例\n\n\n找出现问题的点。正常通过的只用测一次（一路走到底）\n\n因此，对于下面这个新增合同业务，我们可以设计出以下用例：\n\n\n合同新增成功：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）-&gt; 新增合同（成功\n合同新增失败（登录失败）\n合同新增失败 （添加课程失败）：登陆（成功）\n合同新增失败 （上传合同失败）：登录（成功）-&gt; 添加课程（成功）\n合同新增失败 （新增合同失败）：登录（成功）-&gt; 添加课程（成功）-&gt; 上传合同（成功）\n\n5. 接口文档\n\n\n\n\n\n\n\n\n接口API文档一般由后端开发编写，用于描述接口信息。\n\n对于接口测试来讲，主要就是分析接口文档中的三点：\n\n接口之间的依赖关系\n接口请求（URL，请求方法，请求头，请求参数类型，请求参数）\n接口响应（状态码，响应信息）\n\n\n基本就是跟着接口文档，在测试用例里面复制黏贴就行。接口文档里没写的，测试用例里用“&#x2F;”占位。\n\n\n6. Postman\n\n\n\n\n\n\n\n\n一款接口调试工具\n6.1 Demo:验证码接口URL: http://kdtx-test.itheima.net/api/captchaImage\n\n设置请求方式 (GET)\n输入接口地址 (…)\n点击发送请求\n查看响应结果\n\n6.2 Demo: 登录接口URL: http://kdtx-test.itheima.net/api/login 方法： POST\n请求头： Content-Type： application&#x2F;json\n请求体： {“username”:”admin”, “password”:”HM_2023_test”,”code”:”2”,”uuid”:”验证码接口中uuid请求结果”}\n\n设置请求方式 (GET)\n输入接口地址 (…)\n点击发送请求\n查看响应结果\n\n\n问题： 每次使用登录接口，都需要手动复制验证码接口的返回结果，很麻烦\nPostman为我们提供了一个公共容器，用于保存相关联的数据。\n6.3 环境变量\n6.3.1 通过javascript操作响应json，并存入环境变量Postman内置Test，可以运行Javascript。通过这一点，可以动态地获取并保存环境变量\n6.3.1.1 Demo1: 将获取验证码时的uuid存入环境变量，并在登录时填写到requestBody中\n\n6.3.1.1 Demo: 将登录成功后的token存入环境变量，并在添加课程时候填入 RequestHeader中。\n\n6.4 处理mutipart&#x2F;form-data数据接口可能会这样子写\n\n这时候请求体类型就得是form-data类型了。Key看文档，file看文档文件路径。\n\n这里上传接口又依赖登录接口请求成功后，返回的token。因此，需要在登录接口中将token存入环境变量\n\n并在上传接口的Request-Headers，添加Authorization：\n6.5 Postman中的Request Param\n6.6 批量执行\n\n\n\n\n\n\n\n\n这些合同查询、上传、新增操作，都依赖于登录时候提供的token进行鉴权。问题是，用户登录是会过期的。我们不可能每次要去进行操作，都手动把每个接口的流程走一遍，因此，postman提供了批量执行测试用例。\n\n7. 设计接口用例对于 单接口测试，设计思路通常分为两类： 正向测试和逆向（反向）测试\n7.1 正向测试包含： \n\n必填参数 P2\n全部参数 p2\n\n7.2 逆向测试包含：\n\n参数数据为空 p3\n参数类型不符 p3\n参数长度不符 p3\n业务规则不符 p3\n\n正向测试的优先级永远高于逆向测试\n逆向测试可以理解成对正向测试里的参数的对立面进行测试\ne.g. 登录接口测试用例\n\n7.3 Postman按模块管理测试用例\n按照上面的箭头，先在Collection中创建folder，然后再folder中创建对应接口的request测试用例。\n下面是对于登录接口的用户名设计的三个正向和反向测试用例\n\n补票：Postman断言\n\n\n\n\n\n\n\n\nPostman提供了test()方法，用于自动地检测response中的结果是否与预期结果一致。\n常用断言包括：\n\n响应状态码(Status code)\n\n**直接点击对应snippet就会自动再Tests编辑区域生成 **\n\n响应包含指定字符串 (Contains string)\n\nJSON断言（JSON value check)\n写完之后发送下，如果符合预期结果的话，应该是绿色。\n\n\n\n补票：Postman参数化\n\n\n\n\n\n\n\n\n从上面的断言例子可以看出。如果对同一接口进行正反向测试时候，每次测试都需要将Tests内的代码或者是headers、body中的值进行复制黏贴。很麻烦。因此，postman提供了参数化，可以直接准备好的数据文件中，读取数据\n步骤：\n\n准备数据文件\n\n引用数据文件数据\nheaders、body：\n代码：data.key\n\n在批量执行的页面，select file选择数据文件。\n\n\nJSON数据格式：\njson[\n    &#123;&quot;username&quot;:&quot;admin&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;200&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;操作成功&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;,\n    &#123;&quot;username&quot;:&quot;admin1&quot;, &quot;password&quot;:&quot;HM_2023_test&quot;, &quot;status&quot;:&quot;500&quot;, &quot;contain_message&quot;:&quot;作成功&quot;, &quot;msg&quot;: &quot;用户不存在/密码错误&quot;&#125;\n]\n注意，在编写json数据时，务必看好接口文档里的参数类型。如果是string类型则不要忘了双引号。如果是数字类型则不用双引号。\n这里，如果将”status”设为String类型的”200”，则会导致测试用例无法通过。\n如图：\n\n\n\n\n\n\n\n\n\n\n\n下面的用例，有时间可以往postman里填下，练练手。重要的还是看怎么设计用例。填数据没难度。\n7.3.1 Demo: 课程添加接口的用例设计\n因为这个接口依赖于登录成功后返回的token，因此，正向中的两个用例需要补充一下说明：是在登录成功的前提下,进行…..。同理，逆向中，还需要添加一条测试用例：\n7.3.2 课程查询接口的用例设计\n\n\n\n\n\n\n\n\n\n对应的用例文档\n\n\n7.3.3 课程修改接口用例设计\n\n7.3.4 课程删除接口测试用例设计\n\n这里的id是路径参数\n7.3.4.1 路径参数\n\n\n\n\n\n\n\n\nPathVariable\nURL中末尾一级的参数\n如： http://kdtx-test.itheima.net/api/clues/course/111\n在Postman中有两种方式添加Path Variable。第一种就是直接在url中添加，第二种是url末尾加:id\n\n以上内容为接口测试的基础理论与样例。下面是使用TestNG\n\n","slug":"接口自动化","date":"2023-02-12T01:34:49.000Z","categories_index":"软件测试","tags_index":"软件测试","author_index":"Kangwei Zhu"},{"id":"62b3445507f5f3a5e4605095b5d2e37e","title":"标签","content":"","slug":"标签","date":"2022-09-01T10:02:36.000Z","categories_index":"Java基础,Javascript基础,后端开发,前端开发,软件测试,OS,数据库,中间件,算法,Linux问题","tags_index":"Linux,Selenium,Spring,SpringBoot,Mybatis(Plus),Mysql,Redis,Rabbitmq,Kafka,Docker,K8s,xxl-job,Javascript基础,Vue2,React.js,Electron.js,Flutter","author_index":"Kangwei Zhu"},{"id":"233993f5d6768161562aa56f24893a0a","title":"vscode偏好设置","content":"1. 禁用输入括号后自动补全\n\n\n\n\n\n\n\n\n每次写方法&#x2F;函数的时候，当弹出自动补全提示窗口时，恰好你又按了一下”( )”, vscode就会自动为你补全。\n但是事实上你只是想输入括号，而不是输入那个方法。\n对此，我们可以在设置中禁用**acceptSuggestionOnCommitCharacter这一选项。\n","slug":"vscode一些小问题","date":"2022-08-11T16:00:00.000Z","categories_index":"","tags_index":"","author_index":"Kangwei Zhu"}]