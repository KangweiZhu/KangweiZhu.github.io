{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"The method used to calculate the maximum depth of a binary tree does not strictly adhere to the typical in-order, pre-order, or post-order t...","date":"2024-02-23T21:57:36.770Z","updated":"2024-02-23T21:57:36.770Z","comments":true,"path":"api/pages/code/leetcode/tree/dfs/0104. Maximum Depth of Binary Tree.json","covers":null,"excerpt":"","content":"<p>The method used to calculate the maximum depth of a binary tree does not strictly adhere to the typical in-order, pre-order, or post-order traversals. However, if we must categorize it, it most closely resembles a post-order traversal.</p>\n<p>Hereâ€™s why:</p>\n<p>In-order traversal visits nodes in the order: left child, current node, right child.<br>Pre-order traversal visits nodes in the order: current node, left child, right child.<br>Post-order traversal visits nodes in the order: left child, right child, current node.<br>In the maxDepth function, the process is as follows:</p>\n<p>Recursively calculate the depth of the left subtree (maxDepth(root.left)).<br>Recursively calculate the depth of the right subtree (maxDepth(root.right)).<br>Use the depths calculated from the left and right subtrees to calculate the depth of the current node (Math.max(leftDepth, rightDepth) + 1).<br>This process aligns with post-order traversal because the current node (root) is processed after the recursive calls to its left and right children have been made, which is the defining characteristic of post-order traversal.</p>\n","count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"toc":"","data":[]}