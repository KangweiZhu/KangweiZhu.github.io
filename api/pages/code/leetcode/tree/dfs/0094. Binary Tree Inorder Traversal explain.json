{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"What is stackA stack is a fundamental data structure used in computer science to store and manage information in a Last In, First Out (LIFO)...","date":"2024-02-23T21:57:36.770Z","updated":"2024-02-23T21:57:36.770Z","comments":true,"path":"api/pages/code/leetcode/tree/dfs/0094. Binary Tree Inorder Traversal explain.json","covers":null,"excerpt":"","content":"<h2 id=\"What-is-stack\"><a href=\"#What-is-stack\" class=\"headerlink\" title=\"What is stack\"></a>What is stack</h2><p>A stack is a fundamental data structure used in computer science to store and manage information in a Last In, First Out (LIFO) manner. This means the last element added to the stack is the first one to be removed. Stacks are used in various applications, such as parsing expressions, backtracking problems, and function call management in programming languages.</p>\n<p>Key operations associated with a stack include:</p>\n<p>Push: Add an item to the top of the stack.<br>Pop: Remove and return the item at the top of the stack.<br>Peek (or Top): Look at the item at the top of the stack without removing it.<br>IsEmpty: Check if the stack is empty.<br>In the context of the Java code provided for binary tree in-order traversal, a Stack<TreeNode> is used to keep track of the nodes to be visited. As the algorithm traverses the tree:</p>\n<h2 id=\"Nodes-are-pushed-onto-the-stack-as-it-goes-down-the-left-children-of-the-tree-Nodes-are-popped-from-the-stack-when-it’s-time-to-visit-them-after-visiting-all-left-children-The-right-child-of-a-node-is-processed-after-visiting-the-node-itself-in-accordance-with-in-order-traversal-rules-This-use-of-the-stack-allows-the-algorithm-to-temporarily-store-nodes-while-it-navigates-through-the-tree-ensuring-that-nodes-are-visited-in-the-correct-order-without-requiring-recursion\"><a href=\"#Nodes-are-pushed-onto-the-stack-as-it-goes-down-the-left-children-of-the-tree-Nodes-are-popped-from-the-stack-when-it’s-time-to-visit-them-after-visiting-all-left-children-The-right-child-of-a-node-is-processed-after-visiting-the-node-itself-in-accordance-with-in-order-traversal-rules-This-use-of-the-stack-allows-the-algorithm-to-temporarily-store-nodes-while-it-navigates-through-the-tree-ensuring-that-nodes-are-visited-in-the-correct-order-without-requiring-recursion\" class=\"headerlink\" title=\"Nodes are pushed onto the stack as it goes down the left children of the tree.Nodes are popped from the stack when it’s time to visit them (after visiting all left children).The right child of a node is processed after visiting the node itself, in accordance with in-order traversal rules.This use of the stack allows the algorithm to temporarily store nodes while it navigates through the tree, ensuring that nodes are visited in the correct order without requiring recursion.\"></a>Nodes are pushed onto the stack as it goes down the left children of the tree.<br>Nodes are popped from the stack when it’s time to visit them (after visiting all left children).<br>The right child of a node is processed after visiting the node itself, in accordance with in-order traversal rules.<br>This use of the stack allows the algorithm to temporarily store nodes while it navigates through the tree, ensuring that nodes are visited in the correct order without requiring recursion.</h2><h2 id=\"Stack-API-in-java\"><a href=\"#Stack-API-in-java\" class=\"headerlink\" title=\"Stack API in java\"></a>Stack API in java</h2><p>In Java, the Stack class is part of the Java Collection Framework and extends the Vector class. It provides the standard operations associated with a stack data structure, including methods for pushing, popping, peeking, and checking if the stack is empty. Here’s an overview of the key methods provided by the Stack<E> class in Java:</p>\n<p>push(E item): Pushes an item onto the top of the stack. This method adds an element to the stack and returns the item pushed.</p>\n<p>pop(): Removes the item at the top of the stack and returns that item. This method throws an EmptyStackException if the stack is empty.</p>\n<p>peek(): Looks at the item at the top of the stack without removing it from the stack. Like pop(), this method throws an EmptyStackException if the stack is empty.</p>\n<p>isEmpty(): Returns true if the stack is empty; otherwise, it returns false. This method is useful for checking the stack’s state before performing operations that require the stack to have elements.</p>\n<p>search(Object o): Searches for an object in the stack and returns the 1-based position from the top of the stack. If the object is found, this method returns its position; otherwise, it returns -1. This method allows you to check the presence and position of an element in the stack.</p>\n<h2 id=\"Example\"><a href=\"#Example\" class=\"headerlink\" title=\"Example\"></a>Example</h2><div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">    1</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">   / \\</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">  2   3</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\"> / \\</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">4   5</span></span></code></pre></div><p>目标是按照中序遍历的顺序 [4,2,5,1,3] 遍历这棵树。以下是遍历过程的详细步骤：</p>\n<p>初始状态：</p>\n<p>current 指向根节点（1）<br>栈 (stack) 是空的<br>遍历到最左边：</p>\n<p>将 current (1) 压入栈，移动 current 到其左子节点（2）<br>将 current (2) 压入栈，移动 current 到其左子节点（4）<br>将 current (4) 压入栈，因为（4）没有左子节点，继续下一步<br>访问节点并处理右子树：</p>\n<p>弹出栈顶元素（4），将其值加入结果列表，current 为 null（因为（4）没有右子节点）<br>弹出栈顶元素（2），将其值加入结果列表，然后 current 移动到（2）的右子节点（5）<br>处理节点 5：</p>\n<p>（5）直接被访问（因为它没有左子节点），将（5）的值加入结果列表，current 移动到（5）的右子节点（null）<br>回到根节点：</p>\n<p>弹出栈顶元素（1），将其值加入结果列表，current 移动到（1）的右子节点（3）<br>处理节点 3：</p>\n<p>因为（3）没有左子节点，它直接被访问并将值加入结果列表，current 移动到（3）的右子节点（null）<br>结束：</p>\n<p>所有节点都已按照中序遍历的顺序被访问<br>通过上述步骤，我们能够按照“左-根-右”的顺序访问树中的每个节点，即使是使用迭代方式也能正确地完成中序遍历。这个过程展示了如何利用栈来暂存节点，直到它们的左子树被完全遍历，确保了按照中序遍历的顺序访问节点。</p>\n","count_time":{"symbolsCount":"3.2k","symbolsTime":"3 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#What-is-stack\"><span class=\"toc-text\">What is stack</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nodes-are-pushed-onto-the-stack-as-it-goes-down-the-left-children-of-the-tree-Nodes-are-popped-from-the-stack-when-it%E2%80%99s-time-to-visit-them-after-visiting-all-left-children-The-right-child-of-a-node-is-processed-after-visiting-the-node-itself-in-accordance-with-in-order-traversal-rules-This-use-of-the-stack-allows-the-algorithm-to-temporarily-store-nodes-while-it-navigates-through-the-tree-ensuring-that-nodes-are-visited-in-the-correct-order-without-requiring-recursion\"><span class=\"toc-text\">Nodes are pushed onto the stack as it goes down the left children of the tree.Nodes are popped from the stack when it’s time to visit them (after visiting all left children).The right child of a node is processed after visiting the node itself, in accordance with in-order traversal rules.This use of the stack allows the algorithm to temporarily store nodes while it navigates through the tree, ensuring that nodes are visited in the correct order without requiring recursion.</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Stack-API-in-java\"><span class=\"toc-text\">Stack API in java</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Example\"><span class=\"toc-text\">Example</span></a></li></ol>","data":[]}