{"title":"","type":"page","uid":"1cd19fc71517798e2fa5b7457d1fb06e","text":"这道题目前应该是有两种做法，我目前就交了一种看上去比较复杂的方法。首先先说一下，还有一个方法是：同样做in-order遍历，将每个节点提到list里，然后对值做排序，最后按照排序的结果重新对所有节点一次赋值。 但是，不管是那种方法，用到的原理都是一样的，即：in-order tr...","date":"2024-02-23T21:57:36.770Z","updated":"2024-02-23T21:57:36.770Z","comments":true,"path":"api/pages/code/leetcode/tree/dfs/0099. Recover Binary Search Tree.json","covers":null,"excerpt":"","content":"<p>这道题目前应该是有两种做法，我目前就交了一种看上去比较复杂的方法。<br>首先先说一下，还有一个方法是：同样做in-order遍历，将每个节点提到list里，然后对值做排序，最后按照排序的结果重新对所有节点一次赋值。</p>\n<p>但是，不管是那种方法，用到的原理都是一样的，即：in-order traverse时，所有的节点大小，都是<strong>单调递增</strong>的。<br>所以这题只要会in-order traverse就非常简单，用不着gpt了。</p>\n<h2 id=\"不过，有一个小细节java-if-first-null-current-val-previous-val-first-previous-if-first-null-current-val-previous-val-second-current-为什么first-current-second-previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，-1-3-2-first一定是问题的根源，所以锁死3。-走到2的时候发现了-2-3-这个问题，所以second记录到2。-但是2不是最终的问题所在，他只是-临时存在的问题-，因为回到1了之后，我们会发现-3-1。-也就是说，-1才是最后一个发现的问题。-所以将-根源-和-最终的问题-进行替换-。也就是变成这样：-3-1-2\"><a href=\"#不过，有一个小细节java-if-first-null-current-val-previous-val-first-previous-if-first-null-current-val-previous-val-second-current-为什么first-current-second-previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，-1-3-2-first一定是问题的根源，所以锁死3。-走到2的时候发现了-2-3-这个问题，所以second记录到2。-但是2不是最终的问题所在，他只是-临时存在的问题-，因为回到1了之后，我们会发现-3-1。-也就是说，-1才是最后一个发现的问题。-所以将-根源-和-最终的问题-进行替换-。也就是变成这样：-3-1-2\" class=\"headerlink\" title=\"不过，有一个小细节java       if (first == null &amp;&amp; current.val &lt; previous.val) {           first = previous;       }       if (first != null &amp;&amp; current.val &lt; previous.val) {           second = current;       } 为什么first &#x3D; current, second &#x3D; previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，      1      /      3         \\       2 first一定是问题的根源，所以锁死3。 走到2的时候发现了 2 &lt; 3 这个问题，所以second记录到2。 但是2不是最终的问题所在，他只是**临时存在的问题**，因为回到1了之后，我们会发现 3 &gt; 1。 也就是说， 1才是最后一个发现的问题。 所以将 根源 和 最终的问题 进行替换&#96;。也就是变成这样：      3      /      1         \\       2 \"></a>不过，有一个小细节<br><code>java       if (first == null &amp;&amp; current.val &lt; previous.val) &#123;           first = previous;       &#125;       if (first != null &amp;&amp; current.val &lt; previous.val) &#123;           second = current;       &#125; </code><br>为什么first &#x3D; current, second &#x3D; previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，<br><code>      1      /      3         \\       2 </code><br>first一定是问题的根源，所以锁死3。 走到2的时候发现了 2 &lt; 3 这个问题，所以second记录到2。 但是2不是最终的问题所在，他只是**临时存在的问题**，因为回到1了之后，我们会发现 3 &gt; 1。 也就是说， 1才是最后一个发现的问题。 所以将 <strong>根源</strong> 和 <strong>最终的问题</strong> 进行替换&#96;。也就是变成这样：<br><code>      3      /      1         \\       2 </code></h2><p>如果有点抽象，还是不懂的话，我们可以把第一个测试用例改成这样：</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">      4</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">     / </span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    3   </span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">     \\</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">      2 </span></span></code></pre></div><p>这时候，3 是 <strong>第一次发现问题的根节点， 也就是根源</strong>，锁死。<br>2 &lt; 3， 2是<strong>临时存在的问题（也是第一次发现的问题，后续可能还有多个）</strong>， second记录到2。<br>然后回到4， 发现 3 &lt; 4 是正常的，所以此时， <code>最终的问题</code>就是2。那么同样的， 也是将将 <strong>根源</strong> 和 <strong>最终的问题</strong> 进行替换&#96;。也就是变成</p>\n<div class=\"language-txt\"><button title=\"Copy code\" class=\"copy\"></button><span class=\"lang\">txt</span><pre class=\"shiki rose-pine-moon\" style=\"background-color: #232136\" tabindex=\"0\"><code><span class=\"line\"><span style=\"color: #e0def4\">      4</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">     / </span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">    2   </span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">     \\</span></span>\n<span class=\"line\"><span style=\"color: #e0def4\">      3 </span></span></code></pre></div>","count_time":{"symbolsCount":"1.1k","symbolsTime":"1 mins."},"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E8%BF%87%EF%BC%8C%E6%9C%89%E4%B8%80%E4%B8%AA%E5%B0%8F%E7%BB%86%E8%8A%82java-if-first-null-current-val-previous-val-first-previous-if-first-null-current-val-previous-val-second-current-%E4%B8%BA%E4%BB%80%E4%B9%88first-current-second-previous%EF%BC%8C%E8%83%BD%E8%BF%87%E7%AC%AC%E4%BA%8C%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%EF%BC%8C%E4%BD%86%E6%98%AF%E4%B8%8D%E8%83%BD%E8%BF%87%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E5%91%A2%E3%80%82%E5%8F%AF%E4%BB%A5%E6%A8%A1%E6%8B%9F%E4%B8%80%E4%B8%8B%E7%AC%AC%E4%B8%80%E4%B8%AA%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E3%80%82%E7%9C%8B%E4%B8%8B%E6%B5%81%E7%A8%8B%EF%BC%8C-1-3-2-first%E4%B8%80%E5%AE%9A%E6%98%AF%E9%97%AE%E9%A2%98%E7%9A%84%E6%A0%B9%E6%BA%90%EF%BC%8C%E6%89%80%E4%BB%A5%E9%94%81%E6%AD%BB3%E3%80%82-%E8%B5%B0%E5%88%B02%E7%9A%84%E6%97%B6%E5%80%99%E5%8F%91%E7%8E%B0%E4%BA%86-2-3-%E8%BF%99%E4%B8%AA%E9%97%AE%E9%A2%98%EF%BC%8C%E6%89%80%E4%BB%A5second%E8%AE%B0%E5%BD%95%E5%88%B02%E3%80%82-%E4%BD%86%E6%98%AF2%E4%B8%8D%E6%98%AF%E6%9C%80%E7%BB%88%E7%9A%84%E9%97%AE%E9%A2%98%E6%89%80%E5%9C%A8%EF%BC%8C%E4%BB%96%E5%8F%AA%E6%98%AF-%E4%B8%B4%E6%97%B6%E5%AD%98%E5%9C%A8%E7%9A%84%E9%97%AE%E9%A2%98-%EF%BC%8C%E5%9B%A0%E4%B8%BA%E5%9B%9E%E5%88%B01%E4%BA%86%E4%B9%8B%E5%90%8E%EF%BC%8C%E6%88%91%E4%BB%AC%E4%BC%9A%E5%8F%91%E7%8E%B0-3-1%E3%80%82-%E4%B9%9F%E5%B0%B1%E6%98%AF%E8%AF%B4%EF%BC%8C-1%E6%89%8D%E6%98%AF%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8F%91%E7%8E%B0%E7%9A%84%E9%97%AE%E9%A2%98%E3%80%82-%E6%89%80%E4%BB%A5%E5%B0%86-%E6%A0%B9%E6%BA%90-%E5%92%8C-%E6%9C%80%E7%BB%88%E7%9A%84%E9%97%AE%E9%A2%98-%E8%BF%9B%E8%A1%8C%E6%9B%BF%E6%8D%A2-%E3%80%82%E4%B9%9F%E5%B0%B1%E6%98%AF%E5%8F%98%E6%88%90%E8%BF%99%E6%A0%B7%EF%BC%9A-3-1-2\"><span class=\"toc-text\">不过，有一个小细节java       if (first &#x3D;&#x3D; null &amp;&amp; current.val &lt; previous.val) {           first &#x3D; previous;       }       if (first !&#x3D; null &amp;&amp; current.val &lt; previous.val) {           second &#x3D; current;       } 为什么first &#x3D; current, second &#x3D; previous，能过第二个测试用例，但是不能过第一个测试用例呢。可以模拟一下第一个测试用例。看下流程，      1      &#x2F;      3         \\       2 first一定是问题的根源，所以锁死3。 走到2的时候发现了 2 &lt; 3 这个问题，所以second记录到2。 但是2不是最终的问题所在，他只是**临时存在的问题**，因为回到1了之后，我们会发现 3 &gt; 1。 也就是说， 1才是最后一个发现的问题。 所以将 根源 和 最终的问题 进行替换&#96;。也就是变成这样：      3      &#x2F;      1         \\       2 </span></a></li></ol>","data":[]}